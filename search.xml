<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cmake入门</title>
      <link href="/2023/10/26/cmake-ru-men/"/>
      <url>/2023/10/26/cmake-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h2><p>本文使用ubuntu18.04，安装cmake使用如下命令，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><h2 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h2><p>编写简单的main.cpp函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;hello world!!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.cpp相同的目录下编写CMakeLists.txt,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>第一行意思是表示cmake的最低版本要求是2.8，我们安装的是3.10.2；第二行是表示本工程信息，也就是工程名叫demo；第三行比较关键，表示最终要生成的elf文件的名字叫main，使用的源文件是main.c<br>在终端下切到main.c所在的目录下，然后输入以下命令运行cmake，</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><p>可以得到以下文件</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260931968.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260931968.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026093119896"></p><p>生成了Makefile，还有一些cmake运行时生成的文件，输入make，执行后目录下生成了elf文件main，然后运行。</p><p>&#x3D;&#x3D;PS: 如果想重新生成main，输入make clean就可以删除main这个elf文件。&#x3D;&#x3D;</p><h2 id="同一目录下多个源文件"><a href="#同一目录下多个源文件" class="headerlink" title="同一目录下多个源文件"></a>同一目录下多个源文件</h2><p>在同一个目录下有多个源文件，在之前的目录下添加2个文件，testFunc.c和testFunc.h。添加完后整体文件结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260935510.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260935510.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026093548472"></p><p>testFunc.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;data&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testFunc.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TESTFUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TESTFUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>修改main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">666</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改CMakeLists.txt:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.c testFunc.c)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新cmake在make。</p><p>然后运行重新生成的elf文件main</p><p>可以类推，如果在同一目录下有多个源文件，那么只要在add_executable里把所有源文件都添加进去就可以了。但是如果有一百个源文件，再这样做就有点坑了，无法体现cmake的优越性，cmake提供了一个命令可以把指定目录下所有的源文件存储在一个变量中，这个命令就是 aux_source_directory(dir var)。<br>第一个参数dir是指定目录，第二个参数var是用于存放源文件列表的变量。<br>我们在main.c所在目录下再添加2个文件，testFunc1.c和testFunc1.h。添加完后整体文件结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260946887.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260946887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026094633843"></p><p>testFunc1.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testFunc1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;data&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testFunc1.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TESTFUNC1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TESTFUNC1_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>修改main.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testFunc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testFunc1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">666</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="number">888</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改CMakeLists.txt:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用aux_source_directory把当前目录下的源文件存列表存放到变量SRC_LIST里，然后在add_executable里调用SRC_LIST（注意调用变量时的写法）。</p><p>再次执行cmake和make，并运行main.</p><p>aux_source_directory()也存在弊端，它会把指定目录下的所有源文件都加进来，可能会加入一些我们不需要的文件，此时我们可以使用set命令去新建变量来存放需要的源文件，如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>( SRC_LIST</span><br><span class="line"> ./main.c</span><br><span class="line"> ./testFunc1.c</span><br><span class="line"> ./testFunc.c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="不同目录下多个源文件"><a href="#不同目录下多个源文件" class="headerlink" title="不同目录下多个源文件"></a>不同目录下多个源文件</h2><p>一般来说，当程序文件比较多时，我们会进行分类管理，把代码根据功能放在不同的目录下，这样方便查找。那么这种情况下如何编写CMakeLists.txt呢？</p><p>我们把之前的源文件整理一下（新建2个目录test_func和test_func1），整理好后整体文件结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260956863.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310260956863.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026095653816"></p><p>把之前的testFunc.c和testFunc.h放到test_func目录下，testFunc1.c和testFunc1.h则放到test_func1目录下。</p><p>其中，CMakeLists.txt和main.c在同一目录下，内容修改成如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span> (test_func test_func1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">aux_source_directory</span> (test_func SRC_LIST)</span><br><span class="line"><span class="built_in">aux_source_directory</span> (test_func1 SRC_LIST1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span> (main main.c $&#123;SRC_LIST&#125; $&#123;SRC_LIST1&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里出现了一个新的命令：include_directories。该命令是用来向工程添加多个指定头文件的搜索路径，路径之间用空格分隔。<br>因为main.c里include了testFunc.h和testFunc1.h，如果没有这个命令来指定头文件所在位置，就会无法编译。当然，也可以在main.c里使用include来指定路径，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_func/testFunc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_func1/testFunc1.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只是这种写法不好看。<br>另外，我们使用了2次aux_source_directory，因为源文件分布在2个目录下，所以添加2次。</p><h2 id="较正规的组织结构"><a href="#较正规的组织结构" class="headerlink" title="较正规的组织结构"></a>较正规的组织结构</h2><p>正规一点来说，一般会把源文件放到src目录下，把头文件放入到include文件下，生成的对象文件放入到build目录下，最终输出的elf文件会放到bin目录下，这样整个结构更加清晰。让我们把前面的文件再次重新组织下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261009526.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261009526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026100911484"></p><p>我们在最外层目录下新建一个CMakeLists.txt，内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line">#找src目录下的CMakeLists.txt文件    </span><br><span class="line"><span class="built_in">add_subdirectory</span> (src)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里出现一个新的命令add_subdirectory()，这个命令可以向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制的存放位置，具体用法可以百度。<br>这里指定src目录下存放了源文件，当执行cmake时，就会进入src目录下去找src目录下的CMakeLists.txt，所以在src目录下也建立一个CMakeLists.txt，内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span> (. SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span> (../include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span> (main $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里又出现一个新的命令set，是用于定义变量的，EXECUTABLE_OUT_PATH和PROJECT_SOURCE_DIR是CMake自带的预定义变量，其意义如下，</p><ul><li>EXECUTABLE_OUTPUT_PATH ：目标二进制可执行文件的存放位置</li><li>PROJECT_SOURCE_DIR：工程的根目录</li></ul><p>所以，这里set的意思是把存放elf文件的位置设置为工程根目录下的bin目录。（cmake有很多预定义变量，详细的可以网上搜索一下）</p><p>添加好以上这2个CMakeLists.txt后，整体文件结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261017260.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261017260.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026101716214"></p><p>下面来运行cmake，<strong>不过这次先让我们切到build目录下</strong>，然后输入以下命令，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>Makefile会在build目录下生成，然后在build目录下运行make，</p><p>切到bin目录下，发现main已经生成，并运行测试，</p><p>这里解释一下为什么在build目录下运行cmake？从前面几个case中可以看到，如果不这样做，cmake运行时生成的附带文件就会跟源码文件混在一起，这样会对程序的目录结构造成污染，而在build目录下运行cmake，生成的附带文件就只会待在build目录下，如果我们不想要这些文件了就可以直接清空build目录，非常方便。<br><strong>另外一种写法：</strong></p><p>前面的工程使用了2个CMakeLists.txt，最外层的CMakeLists.txt用于掌控全局，使用add_subdirectory来控制其它目录下的CMakeLists.txt的运行。</p><p>上面的例子也可以只使用一个CMakeLists.txt，把最外层的CMakeLists.txt内容改成如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">aux_source_directory</span> (src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span> (include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span> (main $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时，还要把src目录下的CMakeLists.txt删除。</p><h2 id="动态库和静态库的编译控制"><a href="#动态库和静态库的编译控制" class="headerlink" title="动态库和静态库的编译控制"></a>动态库和静态库的编译控制</h2><p>有时只需要编译出动态库和静态库，然后等着让其它程序去使用。让我们看下这种情况该如何使用cmake。首先按照如下重新组织文件，只留下testFunc.h和TestFunc.cpp</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261036940.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261036940.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026103636903"></p><p>我们会在build目录下运行cmake，并把生成的库文件存放到lib目录下。<br>CMakeLists.txt内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (SRC_LIST $&#123;PROJECT_SOURCE_DIR&#125;/testFunc/testFunc.c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span> (testFunc_shared SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"><span class="built_in">add_library</span> (testFunc_static STATIC $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"><span class="built_in">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里又出现了新的命令和预定义变量，</p><p>add_library: 生成动态库或静态库(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)<br>set_target_properties: 设置最终生成的库的名称，还有其它功能，如设置库的版本号等等<br>LIBRARY_OUTPUT_PATH: 库文件的默认输出路径，这里设置为工程目录下的lib目录</p><p>让我们进入build目录下运行<code>cmake ..</code>，成功后再运行make，</p><p>cd到lib目录下进行查看，发现已经成功生成了动态库和静态库，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261123208.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261123208.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026112324162"></p><p>&#x3D;&#x3D;PS：前面使用set_target_properties重新定义了库的输出名称，如果不使用set_target_properties也可以，那么库的名称就是add_library里定义的名称，只是连续2次使用add_library指定库名称时（第一个参数），这个名称不能相同，而set_target_properties可以把名称设置为相同，只是最终生成的库文件后缀不同（一个是.so，一个是.a），这样相对来说会好看点。&#x3D;&#x3D;</p><h2 id="对库进行链接"><a href="#对库进行链接" class="headerlink" title="对库进行链接"></a>对库进行链接</h2><p>既然我们已经生成了库，那么就进行链接测试下。重新建一个工程目录，然后把上节生成的库拷贝过来，然后在在工程目录下新建src目录和bin目录，在src目录下添加一个main.cpp，整体结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261143563.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261143563.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026114314524"></p><p>工程目录下的CMakeLists.txt内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (SRC_LIST $&#123;PROJECT_SOURCE_DIR&#125;/src/main.c)</span><br><span class="line"></span><br><span class="line"><span class="meta"># find testFunc.h</span></span><br><span class="line"><span class="built_in">include_directories</span> ($&#123;PROJECT_SOURCE_DIR&#125;/testFunc/inc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">find_library</span>(TESTFUNC_LIB testFunc HINTS $&#123;PROJECT_SOURCE_DIR&#125;/testFunc/lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span> (main $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span> (main $&#123;TESTFUNC_LIB&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里出现2个新的命令，</p><ul><li>find_library: 在指定目录下查找指定库，并把<strong>库的绝对路径</strong>存放到变量里，其第一个参数是变量名称，第二个参数是库名称，第三个参数是HINTS，第4个参数是路径，其它用法可以参考cmake文档</li><li>target_link_libraries: 把目标文件与库文件进行链接</li></ul><p>使用find_library的好处是在执行<code>cmake ..</code>时就会去查找库是否存在，这样可以提前发现错误，不用等到链接时。</p><p>cd到build目录下，然后运行<code>cmake .. &amp;&amp; make</code>，最后进入到bin目录下查看，发现main已经生成，运行之，</p><p>&#x3D;&#x3D;ps：在lib目录下有testFunc的静态库和动态库，find_library(TESTFUNC_LIB testFunc …默认是查找动态库，如果想直接指定使用动态库还是静态库，可以写成find_library(TESTFUNC_LIB libtestFunc.so …或者find_library(TESTFUNC_LIB libtestFunc.a …&#x3D;&#x3D;</p><p>&#x3D;&#x3D;ps： 查看elf文件使用了哪些库，可以使用readelf -d .&#x2F;xx来查看&#x3D;&#x3D;</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261158618.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261158618.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026115856554"></p><h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如-Wall，-std&#x3D;c++11等，就可以使用add_compile_options来进行操作。<br>这里以一个简单程序来做演示，main.cpp如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_compile_options</span>(-std=c++<span class="number">11</span> -Wall) </span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整体目录结构如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261202487.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261202487.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026120234447"></p><p>然后cd到build目录下，执行<code>cmake .. &amp;&amp; make</code>命令，就可以在bin目录下得到main的elf文件</p><h2 id="添加控制选项"><a href="#添加控制选项" class="headerlink" title="添加控制选项"></a>添加控制选项</h2><p>有时希望在编译代码时只编译一些指定的源码，可以使用cmake的option命令，主要遇到的情况分为2种：</p><ol><li>本来要生成多个bin或库文件，现在只想生成部分指定的bin或库文件</li><li>对于同一个bin文件，只想编译其中部分代码（使用宏来控制）</li></ol><p><strong>第一种情况</strong></p><p>假设我们现在的工程会生成2个bin文件，main1和main2，现在整体结构体如下，</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261506342.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261506342.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026150644273"></p><p>外层的CMakeLists.txt内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">option</span>(MYDEBUG <span class="string">&quot;enable debug compilation&quot;</span> OFF)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_subdirectory</span>(src)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了option命令，其第一个参数是这个option的名字，第二个参数是字符串，用来描述这个option是来干嘛的，第三个是option的值，ON或OFF，也可以不写，不写就是默认OFF。</p><p>然后编写src目录下的CMakeLists.txt，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main1 main1.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MYDEBUG)</span><br><span class="line">    <span class="built_in">add_executable</span>(main2 main2.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;Currently is not in debug mode&quot;</span>)    </span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，这里使用了if-else来根据option来决定是否编译main2.c<br>其中main1.c和main2.c的内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main1\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, this main2\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后cd到build目录下输入<code>cmake .. &amp;&amp; make</code>就可以只编译出main1，如果想编译出main2，就把MYDEBUG设置为ON，再次输入<code>cmake .. &amp;&amp; make</code>重新编译。</p><p>每次想改变MYDEBUG时都需要去修改CMakeLists.txt，有点麻烦，其实可以通过cmake的命令行去操作，例如我们想把MYDEBUG设置为OFF，先cd到build目录，然后输入&#x3D;&#x3D;cmake .. -DMYDEBUG&#x3D;ON&#x3D;&#x3D;，这样就可以编译出main1和main2 （在bin目录下）</p><p><strong>第二种情况</strong></p><p>假设我们有个main.c，其内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WWW1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world1\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WWW2     </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world2\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以通过定义宏来控制打印的信息，我们CMakeLists.txt内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">option</span>(WWW1 <span class="string">&quot;print one message&quot;</span> OFF)</span><br><span class="line"><span class="built_in">option</span>(WWW2 <span class="string">&quot;print another message&quot;</span> OFF)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WWW1)</span><br><span class="line">    <span class="built_in">add_definitions</span>(-DWWW1)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WWW2)</span><br><span class="line">    <span class="built_in">add_definitions</span>(-DWWW2)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.c)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里把option的名字保持和main.c里的宏名称一致，这样更加直观，也可以选择不同的名字。通过与add_definitions()的配合，就可以控制单个bin文件的打印输出了。</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261509030.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202310261509030.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231026150929987"></p><p>cd到build目录下执行<code>cmake .. &amp;&amp; make</code>，然后到bin目录下执行<code>./main</code>，可以看到打印为空，<br>接着分别按照下面指令去执行，然后查看打印效果，</p><ul><li><code>cmake .. -DWWW1=ON -DWWW2=OFF &amp;&amp; make</code></li><li><code>cmake .. -DWWW1=OFF -DWWW2=ON &amp;&amp; make</code></li><li><code>cmake .. -DWWW1=ON -DWWW2=ON &amp;&amp; make</code></li></ul><p>&#x3D;&#x3D;这里有个小坑要注意下：假设有2个options叫A和B，先调用cmake设置了A，下次再调用cmake去设置B，如果没有删除上次执行cmake时产生的缓存文件，那么这次虽然没设置A，也会默认使用A上次的option值。&#x3D;&#x3D;</p><p>所以如果option有变化，要么删除上次执行cmake时产生的缓存文件，要么把所有的option都显式的指定其值。</p>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统</title>
      <link href="/2023/08/06/wen-jian-xi-tong/"/>
      <url>/2023/08/06/wen-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读帮助手册"><a href="#阅读帮助手册" class="headerlink" title="阅读帮助手册"></a>阅读帮助手册</h1><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061532761.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061532761.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806153213726"></p><p><strong>函数调用内存模型</strong></p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061603042.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061603042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806160314003"></p><p><strong>指针类型的参数</strong></p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061607939.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061607939.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806160744902"></p><p><strong>指针参数使用问题</strong></p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061609732.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061609732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806160915693"></p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>出错的条件–&gt;errno–&gt;perror  (ERROR_CHECK)</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>不要从头看到尾，按需查看</p><h1 id="无缓冲的文件IO"><a href="#无缓冲的文件IO" class="headerlink" title="无缓冲的文件IO"></a>无缓冲的文件IO</h1><p>无缓冲指的是无用户态缓冲区，有内核态缓冲区。</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061615828.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061615828.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806161507791"></p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><p>通过用户态的FILE从而改变内核文件缓冲区最后改变了磁盘文件的数据。</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061616003.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061616003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806161628955"></p><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>因为不能直接访问内核态的数据所以将数据的地址存到一个数组里（索引数组）。</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061621487.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061621487.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806162123445"></p><h1 id="open-close"><a href="#open-close" class="headerlink" title="open close"></a>open close</h1><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061659090.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061659090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806165945054"></p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061700140.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061700140.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806170000100"></p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">O_RDONLY</td><td align="center">以只读的方式打开</td></tr><tr><td align="center">O_WRONLY</td><td align="center">以只写的方式打开</td></tr><tr><td align="center">O_RDWR</td><td align="center">以读写的方式打开</td></tr><tr><td align="center">O_CREAT</td><td align="center">如果文件不存在，则创建文件</td></tr><tr><td align="center">O_EXCL</td><td align="center">仅与O_CREAT连用，如果文件存在，则open失败</td></tr><tr><td align="center">O_TRUNC</td><td align="center">如果文件存在，将文件的长度截至0</td></tr><tr><td align="center">O_APPEND</td><td align="center">以追加的方式打开文件，每次调用write时，文件指针自动先移动到文件尾，用于多进程写同一个文件的情况。</td></tr></tbody></table><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061708259.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061708259.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806170814227"></p><h1 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h1><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061712908.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061712908.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806171214857"></p><h1 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h1><p>如果open的flags存在O_CREAT,请使用3参数的版本。</p><table><thead><tr><th align="center">fopen() mode</th><th align="center">open() flags</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">O_RDONLY</td></tr><tr><td align="center">w</td><td align="center">O_WRONLY  |  O_CREAT  |  O_TRUNC</td></tr><tr><td align="center">a</td><td align="center">O_WRONLY   |   O_CREAT  |  APPEND</td></tr><tr><td align="center">r+</td><td align="center">O_RDWR</td></tr><tr><td align="center">w+</td><td align="center">O_RDWR  |  O_CREAT  |  O_TRUNC</td></tr><tr><td align="center">a+</td><td align="center">O_RDWR  |   O_CREAT   |   O_APPEND</td></tr></tbody></table><h1 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h1><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061721573.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308061721573.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806172107526"></p><h1 id="文本文件-二进制文件"><a href="#文本文件-二进制文件" class="headerlink" title="文本文件 二进制文件"></a>文本文件 二进制文件</h1><p>将二进制文件转化成十进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：%！xxd    </span><br></pre></td></tr></table></figure><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062024420.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062024420.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806202424385"></p><p>将字符串写入文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//文本文件</span><br><span class="line"></span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ARGS_CHECK(argc,2);</span><br><span class="line">    int fd = open(argv[1],O_WRONLY|O_CREAT);</span><br><span class="line">    ERROR_CHECK(fd,-1,&quot;open fd&quot;);</span><br><span class="line">    write(fd,&quot;10000000&quot;,8);</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将二进制数据写入文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//二进制文件</span><br><span class="line"></span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ARGS_CHECK(argc,2);</span><br><span class="line">    int fd = open(argv[1],O_WRONLY|O_CREAT);</span><br><span class="line">    ERROR_CHECK(fd,-1,&quot;open fd&quot;);</span><br><span class="line">    int val=10000000;</span><br><span class="line">    write(fd,&amp;val,sizeof(val));</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6个读写的函数"><a href="#6个读写的函数" class="headerlink" title="6个读写的函数"></a>6个读写的函数</h1><p>**FILE: **</p><ul><li>fread</li><li>fwrite</li><li>fscanf             (“10000000”  –&gt;  fscanf(“%d”,&amp;val)  –&gt;  val&#x3D;10000000)</li><li>fprintf        –&gt;     文件总是文本的</li></ul><p><strong>fd:</strong></p><p>read,write  文件是文本的，读到的字符串。文件时二进制，怎么写就怎么读。</p><h1 id="二进制的读操作"><a href="#二进制的读操作" class="headerlink" title="二进制的读操作"></a>二进制的读操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ARGS_CHECK(argc,2);</span><br><span class="line">    int fd = open(argv[1],O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd,-1,&quot;open fd&quot;);</span><br><span class="line">    int val;                      //读的是二进制</span><br><span class="line">    read(fd,&amp;val,sizeof(val));</span><br><span class="line">    printf(&quot;val=%d\n&quot;,val);</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入read"><a href="#深入read" class="headerlink" title="深入read"></a>深入read</h1><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062145874.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062145874.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806214509807"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ARGS_CHECK(argc,2);</span><br><span class="line">    int fd=open(argv[1],O_RDONLY);  //打开的是磁盘文件 </span><br><span class="line">    ERROR_CHECK(fd,-1,&quot;open&quot;);</span><br><span class="line">    char buf[1024];</span><br><span class="line">    ssize_t set = read(fd,buf,4);</span><br><span class="line">    printf(&quot;set=%d   buf=%s \n&quot;,set,buf);</span><br><span class="line">    memset(buf,0,sizeof(buf));</span><br><span class="line">    set = read(fd,buf,4);</span><br><span class="line">    printf(&quot;set=%d   buf=%s \n&quot;,set,buf);</span><br><span class="line">    memset(buf,0,sizeof(buf));</span><br><span class="line">    set = read(fd,buf,4);</span><br><span class="line">    printf(&quot;set=%d   buf=%s \n&quot;,set,buf);</span><br><span class="line">    memset(buf,0,sizeof(buf));</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="read设备文件"><a href="#read设备文件" class="headerlink" title="read设备文件"></a>read设备文件</h1><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062200177.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062200177.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806220023143"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//read设备会引发阻塞</span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1024]=&#123;0&#125;;</span><br><span class="line">    ssize_t set = read(STDIN_FILENO,buf,sizeof(buf));</span><br><span class="line">    printf(&quot;set=%ld    buf=%s \n&quot;,set,buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="read-write-实现一个cp命令"><a href="#read-write-实现一个cp命令" class="headerlink" title="read write 实现一个cp命令"></a>read write 实现一个cp命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;func.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ARGS_CHECK(argc,3);</span><br><span class="line">    int fd1 = open(argv[1],O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fd1,-1,&quot;open fd1&quot;);</span><br><span class="line">    int fd2 = open(argv[2],O_WRONLY|O_CREAT,0666);</span><br><span class="line">    ERROR_CHECK(fd2,-1,&quot;open fd2&quot;);</span><br><span class="line">    char buf[1024];</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        ssize_t set = read(fd1,buf,sizeof(buf));</span><br><span class="line">        if(!set)break;</span><br><span class="line">        write(fd2,buf,set);</span><br><span class="line">&#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  (const void *s1,const void *s2,size_t n);</span><br><span class="line">//比较s1和s2的n个字符是否相等</span><br></pre></td></tr></table></figure><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062223278.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062223278.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806222330240"></p><h1 id="lseek-更改偏移量"><a href="#lseek-更改偏移量" class="headerlink" title="lseek 更改偏移量"></a>lseek 更改偏移量</h1><p>每次读文件的一个字符读完偏移到下一位，读到小写字母则偏移回来，改成大写字母。</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062227923.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062227923.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806222751874"></p><h1 id="更改文件大小"><a href="#更改文件大小" class="headerlink" title="更改文件大小"></a>更改文件大小</h1><p>使用ftruncate函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ftruncate(int fd , off_t length);</span><br><span class="line">//在执行完ftruncate之后，在新空间的末尾写入一个或以上字节的数据（不为Ox00），这样新空间则不为空，文件系统会把这部分空间当成这个文件的私有空间处理，而不会出现文件大小改变的情况。</span><br></pre></td></tr></table></figure><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062233488.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062233488.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806223301445"></p><h1 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h1><p>我们知道lseek()系统调用可以改变文件的偏移量，但如果程序调用使得文件偏移量跨越了文件结尾，然后再执行I&#x2F;O操作，将会发生什么情况？ read()调用将会返回0，表示文件结尾。令人惊讶的是，write()函数可以在文件结尾后的任意位置写入数据。在这种情况下，对该文件的下一次写将延长该文件，并在文件中构成一个空洞，这一点是允许的。从原来的文件结尾到新写入数据间的这段空间被成为文件空洞。调用write后文件结尾的位置已经发生变化。</p><p>空洞文件就是有空洞的文件,在日常的常识中,我们使用的文件存放在硬盘分区上的时候,有多大的内容就会占用多大的空间,比如这个文本文件里面写有1000个asc字符,那么就会占用磁盘上1000B的存储空间,为了便于管理文件,文件系统都是按块大小来分配给文件的,假如这个文件系统一个块是4096的话,那么这个文件就会占用一个块的,无论实际的内容是1B还是4000B.如果我们有一个4MB的文件,那么它会在分区中占用:4MB&#x2F;4096B&#x3D;1000个块.</p><p>现在我们先做一个实际的无空洞文件来看看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#dd if=/dev/urandom of=testfile1 bs=4096 count=1000</span><br></pre></td></tr></table></figure><p>这个命令会从&#x2F;dev&#x2F;urandom文件复制1000个块,每块大小4096,到testfile1文件去.<br>好了,我们已经有了testfile1这么一个4M的文件了,里面填充了一些随机的内容,你可以more一下.然后用ls -l查看这个文件的大小是4096000,用du -h testfile1来查看的话,文件占用的磁盘大小是4M,两者是一样的.</p><p>下来是我们的重点,空洞文件,假如我们有一个文件,它有4M的大小,但是它里边很大一部分都是没有存放数据的,这样可不可以呢?试一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#dd if=/dev/urandom of=testfile2 bs=4096 seek=999 count=1</span><br></pre></td></tr></table></figure><p>这个命令跟前一个命令相似,不同的是,它其实复制了1个块的内容,前面的999个块都跳过了。我们ls -l一下,发现文件的大小还是4096000,用du -h testfile2查看,占用的块大小是4K。我们发现,虽然文件是4M,但是实际在磁盘上只占用了4K的大小,这就是空洞文件的神奇之处.</p><p>实际中的空洞文件会在哪里用到呢?常见的场景有两个:<br>一是在下载电影的时候,发现刚开始下载,文件的大小就已经到几百M了.<br>二是在创建虚拟机的磁盘镜像的时候,你创建了一个100G的磁盘镜像,但是其实装起来系统之后,开始也不过只占用了3,4G的磁盘空间,如果一开始把100G都分配出去的话,无疑是很大的浪费.</p><p><img src="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062236458.png" class="lazyload placeholder" data-srcset="https://yutan.oss-cn-hangzhou.aliyuncs.com/img/202308062236458.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230806223617415"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/2023/08/06/wen-jian/"/>
      <url>/2023/08/06/wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>在 C 语言中，<strong>流</strong> (stream) 表示任意输入的源或任意输出的目的地。流是一个抽象的概念，它即可以表示存储硬盘上的文件，也可以表示网络端口或者打印设备。流这个概念可以很好地屏蔽硬件设备之间的差异，使得 C 语言可以像读写文件一样读写任意的设备。</p><h3 id="文件缓冲"><a href="#文件缓冲" class="headerlink" title="文件缓冲"></a>文件缓冲</h3><p>缓冲区是以<strong>先进先出</strong>的方式管理数据的。缓冲区分为三种类型：</p><ul><li>满缓冲。当缓冲区空时，从输入流中读取数据；当缓冲区满时，向输出流中写入数据。</li><li>行缓冲。每次从输入流中读取一行数据；每次向输出流中写入一行数据 (stdin,stdout)。</li><li>无缓冲。顾名思义，就是没有缓冲区 (stderr)。</li></ul><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>C 语言对流的访问是通过<strong>文件指针</strong>实现的，它的类型为 FILE* 。并且在 &lt;stdio.h&gt; 头文件中提供了 3 个标准流。这 3 个标准流可以直接使用——我们不需要对其进行声明，也不用打开或者关闭它们。</p><h3 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h3><p>C 语言支持两种类型的文件：文本文件和二进制文件。文本文件中存储的是字符数据，人类是可以看懂的；二进制文件中的数据，人类是看不懂的。</p><p>文本文件具有两个独特的性质：</p><ul><li><strong>文本文件有行的概念</strong>。文本文件被划分为若干行，并且每一行的结尾都以特殊字符进行标记。在 Windows 系统中，是以回车符和换行符 (\r\n) 进行标记的；在 Unix和 Macintosh 系统中是以换行符 (\n) 标记的。早期的 Macintosh 是以回车符 (\r) 标记每一行的结尾的。</li><li><strong>文本文件可能包含一个特殊的</strong> “<strong>文件末尾</strong>“ <strong>标记</strong>。一些操作系统允许在文本文件的末尾使用一个特殊的字节作为标记。在 Windows 系统中，这个标记为 ‘\x1a’(Ctrl+Z)。Ctrl+Z不是必需的，但如果存在，它就标志着文件的结束，其后的所有字节都会被忽略。大多数其他操作系统 (包括 UNIX) 是没有文件末尾字符。使用 Ctrl+Z 的这一习惯继承自 DOS，而 DOS 中的这一习惯又是从 CP&#x2F;M (早期用于个人电脑的一种操作系统) 来的。</li></ul><p>文本形式可以方便人类阅读和编辑；二进制形式可以节省空间，并且转换效率高。</p><h2 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开&#x2F;关闭文件"></a>打开&#x2F;关闭文件</h2><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* fopen(const char* filename, const char* mode);</span><br><span class="line">#第一个参数是文件路径，第二个参数是打开文件的模式。如果文件无法打开，返回空指针。</span><br></pre></td></tr></table></figure><p><strong>文件路径</strong></p><p>绝对路径：从根目录 (或者盘符) 开始，一直到文件所在的位置，比如：”c:&#x2F;project&#x2F;test.dat”。相对路径：从当前工作目录开始，一直到文件所在的位置，比如：”in.dat”。</p><p><strong>模式</strong></p><p>文本形式：</p><table><thead><tr><th align="center"><strong>模式字符串</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">“r”</td><td align="center">打开文件用于读</td></tr><tr><td align="center">“w”</td><td align="center">打开文件用于写 (文件不存在则创建)</td></tr><tr><td align="center">“a”</td><td align="center">打开文件用于追加 (文件不存在则创建)</td></tr><tr><td align="center">“r+”</td><td align="center">打开文件用于读和写，从文件头开始</td></tr><tr><td align="center">“w+”</td><td align="center">打开文件用于读和写 (文件不存在则创建)</td></tr><tr><td align="center">“a+”</td><td align="center">打开文件用于读和写 (文件不存在则创建)</td></tr></tbody></table><p>二进制打开：</p><table><thead><tr><th align="center"><strong>模式字符串</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">“rb”</td><td align="center">打开文件用于读</td></tr><tr><td align="center">“wb”</td><td align="center">打开文件用于写 (文件不存在则创建)</td></tr><tr><td align="center">“ab”</td><td align="center">打开文件用于追加 (文件不存在则创建)</td></tr><tr><td align="center">“r+b” 或 “rb+”</td><td align="center">打开文件用于读和写，从文件头开始</td></tr><tr><td align="center">“w+b” 或 “wb+”</td><td align="center">打开文件用于读和写 (文件不存在则创建)</td></tr><tr><td align="center">“a+b” 或 “ab+”</td><td align="center">打开文件用于读和写 (文件不存在则创建)</td></tr></tbody></table><p>写模式和追加模式是不一样的。如果文件存在，写模式会清空原有的数据，而追加模式会在原有数据的后面写入新的内容。</p><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><p>fclose 可以关闭程序不再使用的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fclose(FILE* stream);</span><br></pre></td></tr></table></figure><p>如果成功关闭， fclose 返回零；否则返回 EOF。</p><p>注意：当不再使用某个文件时，一定要及时关闭该文件。</p><h2 id="读-写文件"><a href="#读-写文件" class="headerlink" title="读&#x2F;写文件"></a>读&#x2F;写文件</h2><p>前面介绍了如何打开和关闭文件，接下来我们来学习下如何读写文件。其中fgetc&#x2F;fputc , fgets&#x2F;fputs 和 fscanf&#x2F;fprintf 是用来读写文本文件的；fread&#x2F;fwrite 是用来读写二进制文件的。</p><h3 id="fgetc-fputc"><a href="#fgetc-fputc" class="headerlink" title="fgetc&amp;fputc"></a>fgetc&amp;fputc</h3><p><strong>fgetc</strong></p><p>fgetc 可以从输入流中读取一个字符，如果读取成功，返回读取的字符；如果读到文件末尾，或者读取失败，返回 EOF。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fgetc(FILE* stream);</span><br></pre></td></tr></table></figure><p>fgetc 和 getchar 类似。不同的是 getchar 只能从标准输入流(stdin)中读取字符，而 fgetc 可以从任意一个输入流中读取字符。</p><p><strong>fputc</strong></p><p>fputc 可以向输出流中写入一个字符，如果写入成功，返回写入的字符；如果写入失败，返回EOF。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fputc(int c, FILE* stream);</span><br></pre></td></tr></table></figure><p>fputc 和 putchar 类似。不同的是 putchar 只能向标准输出流(stdout)中写入字符，而 fputc 可以向任意一个流中写入字符。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// fcopy.c</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    // copy src dest</span><br><span class="line"> if (argc != 3) &#123;</span><br><span class="line"> printf(&quot;Error: invalid arguments\n&quot;);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> // 打开文件流</span><br><span class="line"> FILE* source_fp = fopen(argv[1], &quot;r&quot;);</span><br><span class="line"> if (source_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> FILE* dest_fp = fopen(argv[2], &quot;w&quot;);</span><br><span class="line"> if (dest_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[2]);</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> // 复制文件</span><br><span class="line"> int c;</span><br><span class="line"> while ((c = fgetc(source_fp)) != EOF)</span><br><span class="line"> fputc(c, dest_fp);</span><br><span class="line"> </span><br><span class="line">    // 关闭文件流</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> fclose(dest_fp);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets&amp;fputs"></a>fgets&amp;fputs</h3><p>一次性可以读写一行的函数 fgets 和 fputs 。</p><p><strong>fgets</strong></p><p>从输入流 stream 中，最多读取 count - 1 个字符，并把读取的字符存入 str 指向的字符数组中。 fgets 遇到换行符’\n’，或者文件的末尾就会终止(也就是说，读取的字符数可能不足 count - 1 个)，并且会存储换行符’\n’。 fgets 会在最后添加空字符’\0’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char* fgets(char* str, int count, FILE* stream);</span><br><span class="line">参数：</span><br><span class="line">    str: 指向一个字符数组</span><br><span class="line">    count: 能够写入的最大字符数量(通常是str指向字符数组的长度)</span><br><span class="line">    stream: 输入流</span><br><span class="line">返回值：</span><br><span class="line"> 成功：返回str</span><br><span class="line">    失败：NULL</span><br></pre></td></tr></table></figure><p>fgets 是 gets 的通用版本，它可以从任意输入流中读取数据，而 gets 只能从stdin 中读取数据。 fgets 也比 gets 更为安全，因为它限制了读取字符的最大数目(count - 1)。此外，如果 fgets 是因为读取了换行符而终止，那么它会存储换行符’\n’，而 gets 函数从来不会存储换行符。</p><p><strong>fputs</strong></p><p>将 str 指向的字符串，写入输出流 stream 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fputs(const char* str, FILE* stream);</span><br><span class="line">参数：</span><br><span class="line">    str: 要写的字符串(以&#x27;\0&#x27;结尾的字符串)</span><br><span class="line">    stream: 输出流</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回一个非负值。</span><br><span class="line">    失败：返回EOF，并设置errno。</span><br></pre></td></tr></table></figure><p>fputs 是 puts 的通用版本，它可以将字符串写入到任意的输出流中，而 puts 只能写入到 stdout 中。此外， fputs 是原样输出字符串，而 puts 会在字符串后面而外输出一个换行符’\n’。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// fcopy.c</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    // copy src dest</span><br><span class="line"> if (argc != 3) &#123;</span><br><span class="line">3 . 3 f s c anf &amp; fprintf</span><br><span class="line">fscanf</span><br><span class="line">fscanf 和 scanf 类似，是用来进行格式化输入的。</span><br><span class="line">不同的是， scanf 是从标准输入(stdin)中读取数据，而 fscanf 可以从任何一个流</span><br><span class="line">中读取数据。也就是说，当 fscanf 的第一个参数为 stdin 时，它的效果等价于</span><br><span class="line">scanf 。</span><br><span class="line"> printf(&quot;Error: invalid arguments\n&quot;);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> // 打开文件流</span><br><span class="line"> FILE* source_fp = fopen(argv[1], &quot;r&quot;);</span><br><span class="line"> if (source_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> FILE* dest_fp = fopen(argv[2], &quot;w&quot;);</span><br><span class="line"> if (dest_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[2]);</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> // 复制文件</span><br><span class="line"> char str[1024];</span><br><span class="line"> while (fgets(str, sizeof(str), source_fp) != NULL)</span><br><span class="line"> fputs(str, dest_fp);</span><br><span class="line"> </span><br><span class="line">    // 关闭文件流</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> fclose(dest_fp);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fscanf-fprintf"><a href="#fscanf-fprintf" class="headerlink" title="fscanf&amp;fprintf"></a>fscanf&amp;fprintf</h3><p><strong>fscanf</strong></p><p>fscanf 和 scanf 类似，是用来进行格式化输入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fscanf(FILE* stream, const char* format, ...);</span><br></pre></td></tr></table></figure><p>不同的是， scanf 是从标准输入(stdin)中读取数据，而 fscanf 可以从任何一个流中读取数据。也就是说，当 fscanf 的第一个参数为 stdin 时，它的效果等价于scanf 。顺便提一下， sscanf 可以从字符串中读取数据。</p><p><strong>fprintf</strong></p><p>fprintf 和 printf 类似，是用来进行格式化输出的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fprintf(FILE* stream, const char* format, ...);</span><br></pre></td></tr></table></figure><p>不同的是， printf 始终是向标准输出(stdout)写入内容的，而 fprintf 可以向任何一个输出流中写入内容。也就是说，当 fprintf 的第一个参数为 stdout 时，它的效果等价于 printf 。</p><p>顺便提一下， sprintf 可以将内容写入到一个字符数组中。</p><p>格式化输入输出，可以用于序列化和反序列化过程中。所谓<strong>序列化</strong>，就是将程序中的对象转换成一种可以保存的格式(二进制或文本)，从而方便存储(存储到文件或数据库中)或传输(通过网络传输给另一台机器)。<strong>反序列化</strong>则是序列化的逆过程，它将按一定格式存储的数据转换成程序中的对象。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line"> char name[25];</span><br><span class="line"> int age;</span><br><span class="line"> char gender;</span><br><span class="line">&#125;Student_t;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"> if (argc != 2) &#123;</span><br><span class="line"> printf(&quot;Error: invalid arguments\n&quot;);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t s = &#123; &quot;xixi&quot;, 18, &#x27;f&#x27; &#125;;</span><br><span class="line"> FILE* fp = fopen(argv[1], &quot;w&quot;);</span><br><span class="line"> if (fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    // 序列化</span><br><span class="line"> fprintf(fp, &quot;%s %d %c&quot;, s.name, s.age, s.gender);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> fp = fopen(argv[1], &quot;r&quot;);</span><br><span class="line"> if (fp == NULL) &#123;</span><br><span class="line">3 . 4 fr e ad &amp; f writ e</span><br><span class="line">fread 和 fwrite 主要是用来处理二进制文件的。 fread 可以每次读取一大块数</span><br><span class="line">据， fwrite 可以每次写入一大块数据。</span><br><span class="line">fread 从输入流 stream 中，最多读取 count 个元素，并把它们依次存放到 buffer 指</span><br><span class="line">向的数组中。</span><br><span class="line">fwrite 将存放在 buffer 指向的数组中的 count 个元素写入到输出流 stream 中。</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t t;</span><br><span class="line">    // 反序列化</span><br><span class="line"> fscanf(fp, &quot;%s %d %c&quot;, t.name, &amp;t.age, &amp;t.gender);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fread-frwrite"><a href="#fread-frwrite" class="headerlink" title="fread&amp;frwrite"></a>fread&amp;frwrite</h3><p>fread 和 fwrite 主要是用来处理二进制文件的。 fread 可以每次读取一大块数据， fwrite 可以每次写入一大块数据。</p><p>fread 从输入流 stream 中，最多读取 count 个元素，并把它们依次存放到 buffer 指向的数组中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void* buffer, size_t size, size_t count, FILE* stream);</span><br><span class="line">参数：</span><br><span class="line">    buffer: 指向存放数据的数组</span><br><span class="line">    size: 每个元素的大小(以字节为单位)</span><br><span class="line">    count: 最多可以读取的元素个数</span><br><span class="line">    stream: 输入流</span><br><span class="line">返回值：</span><br><span class="line">    成功读取元素的个数。当读到文件末尾，或者发生错误时，返回值可能小于count。</span><br><span class="line">    我们可以通过feof和ferror函数来判断，到底是读到了文件末尾，还是发生了错误。</span><br></pre></td></tr></table></figure><p>fwrite 将存放在 buffer 指向的数组中的 count 个元素写入到输出流 stream 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void* buffer, size_t size, size_t count, FILE*</span><br><span class="line">stream);</span><br><span class="line">参数：</span><br><span class="line"> buffer: 指向存放数据的数组。</span><br><span class="line">返回值：</span><br><span class="line"> 成功写入元素的个数。当发生错误时，这个值可能小于count。</span><br></pre></td></tr></table></figure><p>fread&#x2F;fwrite 不仅可以用于读写二进制文件，还可以用于序列化和反序列化过程中。</p><p><strong>示例</strong>1 (复制二进制文件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// fcopy.c</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"> if (argc != 3) &#123;</span><br><span class="line"> printf(&quot;Error: invalid arguments\n&quot;);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> FILE* source_fp = fopen(argv[1], &quot;rb&quot;);</span><br><span class="line"> if (source_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> FILE* dest_fp = fopen(argv[2], &quot;wb&quot;);</span><br><span class="line"> if (dest_fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[2]);</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> // 复制二进制文件</span><br><span class="line"> char buffer[1024];</span><br><span class="line"> int n;</span><br><span class="line"> while ((n = fread(buffer, 1, sizeof(buffer), source_fp)) != 0)</span><br><span class="line"> fwrite(buffer, 1, n, dest_fp);</span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> fclose(dest_fp);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>2 (序列化&#x2F;反序列化)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line"> char name[25];</span><br><span class="line"> int age;</span><br><span class="line"> char gender;</span><br><span class="line">&#125;Student_t;</span><br><span class="line">4 . 文件定位</span><br><span class="line">每个流都有相关联的文件位置。在执行读写操作时，文件位置会自动推进，并按照顺</span><br><span class="line">序访问文件。顺序访问是很好的，但是有时候，我们可能需要跳跃地访问文件。为</span><br><span class="line">此，&lt;stdio.h&gt; 提供了几个函数来支持这种能力：</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"> if (argc != 2) &#123;</span><br><span class="line"> printf(&quot;Error: invalid arguments\n&quot;);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t s = &#123; &quot;xixi&quot;, 18, &#x27;f&#x27; &#125;;</span><br><span class="line"> FILE* fp = fopen(argv[1], &quot;wb&quot;);</span><br><span class="line"> if (fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    // 序列化</span><br><span class="line"> fwrite(&amp;s, sizeof(Student_s), 1, fp);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> fp = fopen(argv[1], &quot;rb&quot;);</span><br><span class="line"> if (fp == NULL) &#123;</span><br><span class="line"> printf(&quot;Cannot open %s\n&quot;, argv[1]);</span><br><span class="line"> exit(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t t;</span><br><span class="line">    // 反序列化</span><br><span class="line"> fread(&amp;t, sizeof(Student_s), 1, fp);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>每个流都有相关联的文件位置。在执行读写操作时，文件位置会自动推进，并按照顺序访问文件。顺序访问是很好的，但是有时候，我们可能需要跳跃地访问文件。为此，&lt;stdio.h&gt; 提供了几个函数来支持这种能力：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE* stream, long int offset, int whence);</span><br><span class="line">long int ftell(FILE* stream);</span><br><span class="line">void rewind(FILE* stream);</span><br></pre></td></tr></table></figure><p><strong>fseek</strong></p><p>fseek 可以改变与 stream 相关联的文件位置。其中 whence 表示参照点，参照点有3 个选择：</p><p>SEEK_SET：文件的起始位置。</p><p>SEEK_CUR：文件的当前位置。</p><p>SEEK_END：文件的末尾位置。</p><p>offset 表示偏移量 (可能为负)，它是以字节进行计数的。比如：移动到文件的起始位置，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, 0L, SEEK_SET);</span><br></pre></td></tr></table></figure><p>移动到文件的末尾，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, 0L, SEEK_END);</span><br></pre></td></tr></table></figure><p>往回移动 10 个字节，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, -10L, SEEK_CUR);</span><br></pre></td></tr></table></figure><p>通常情况下， fseek 会返回 0；如果发生错误 (比如，请求的位置不存在)，那么fseek 会返回非 0 值。</p><p><strong>ftell</strong></p><p>ftell 以长整数形式返回当前文件位置；如果发生错误， ftell 返回 -1L。 ftell一般的用法是：记录当前位置，方便以后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long int filePos = ftell(fp);</span><br><span class="line">...</span><br><span class="line">fseek(fp, filePos, SEEK_SET);</span><br></pre></td></tr></table></figure><p><strong>rewind</strong></p><p>rewind 会将文件位置设置为起始位置，类似于调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, 0L, SEEK_SET);</span><br></pre></td></tr></table></figure><p><strong>课堂小练习</strong></p><p>用户输入文件名，将整个文件的内容读入到字符数组中，并在后面添加空字符’\0’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* readFile(const char* path);</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误的检测和处理并不是 C 语言的强项，C 语言没有其它高级语言 (C++, Java, C#等) 所具有的异常处理机制。C 语言往往是通过函数的返回值，或者是测试 errno 变量来检测错误的；并且需要程序员自己编写代码来处理错误。</p><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>errno 是一个 int 类型的全局变量 (C11 修改为线程本地变量，即每个线程都有一个独有的 errno 变量)，它定义在 &lt;errno.h&gt; 头文件中。标准库中有些函数 (比如与文件相关的一些函数)，如果在调用过程中发生了错误，它会设置 errno 的值，以表明发生了何种类型的错误。</p><p>程序启动时，会将 errno 的值设为 0，表示没有错误发生。其它非 0 值都表示发生了某种类型的错误。我们可以通过 perror 和 strerror 来显示错误信息。其中，perror 定义在 &lt;stdio.h&gt; 头文件中， strerror 定义在 &lt;string.h&gt; 头文件中。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// error.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, errno);</span><br><span class="line">    FILE* fp = fopen(&quot;not_exist.txt&quot;, &quot;r&quot;);</span><br><span class="line">    printf(&quot;%d\n&quot;, errno);</span><br><span class="line">    printf(&quot;%s\n&quot;, strerror(errno));</span><br><span class="line">    if(errno != 0) &#123;</span><br><span class="line">        perror(&quot;not_exist.txt&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录</title>
      <link href="/2023/08/06/mu-lu/"/>
      <url>/2023/08/06/mu-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h2><p><strong>获取当前工作目录</strong></p><p>我们可以调用库函数 getcwd 获取当前工作目录的绝对路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">char *getcwd(char *buf, size_t size);</span><br><span class="line">参数</span><br><span class="line">    buf: 指向存放当放当前目录的数组</span><br><span class="line">    size: 数组的大小</span><br><span class="line">返回值</span><br><span class="line">    成功：返回包含当前工作目录的字符串。如果buf不为NULL，即返回buf。</span><br><span class="line">    失败：返回NULL，并设置errno。</span><br></pre></td></tr></table></figure><p>如果传入的 buf 为 NULL ，且 size 为 0，则 getcwd 会调用 malloc 申请合适大小的内存空间，填入当前工作目录的绝对路径，然后返回 malloc 申请的空间的地址。</p><p>注意： getcwd 不负责 free 申请的空间， free 是调用者的职责。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// getcwd.c</span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    // char buf[10];</span><br><span class="line">    // 由系统调用malloc，动态申请内存空间</span><br><span class="line">    char* cwd = getcwd(NULL, 0);</span><br><span class="line">    ERROR_CHECK(cwd, NULL, &quot;getcwd&quot;);</span><br><span class="line">    </span><br><span class="line">    puts(cwd);</span><br><span class="line">    // 由调用者负责释放申请的内存空间</span><br><span class="line">    free(cwd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改变当前工作目录</strong></p><p>chdir 函数可以改变当前工作目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chdir(const char *path);</span><br><span class="line">参数</span><br><span class="line">    path: 改变后的路径。</span><br><span class="line">返回值</span><br><span class="line">   成功：返回0。</span><br><span class="line">    失败：返回-1，并设置errno。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;func.h&gt;</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    // ./chdir dir</span><br><span class="line">    ARGS_CHECK(argc, 2);</span><br><span class="line">    </span><br><span class="line">    char buf[256];</span><br><span class="line">    getcwd(buf, SIZE(buf)); // 获取当前工作目录</span><br><span class="line">    puts(buf); // 打印当前工作目录</span><br><span class="line">    </span><br><span class="line">    int ret = chdir(argv[1]); // 改变当前工作目录</span><br><span class="line">    ERROR_CHECK(ret, -1, &quot;chdir&quot;);</span><br><span class="line">    getcwd(buf, SIZE(buf));</span><br><span class="line">    puts(buf); // 再一次打印当前工作目录，观察一下是否发生了变化</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当前工作目录是进程的属性，也就是说每一个进程都有自己的当前工作目录。且父进程创建(fork)子进程的时候，子进程会继承父进程的当前工作目录。(PS: 进程相关知识后面会详细讲解~)</p><p><strong>创建目录</strong></p><p>mkdir 函数可以用来创建目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">参数</span><br><span class="line">    pathname: 要创建目录的路径</span><br><span class="line"> mode: 目录的权限位，会受文件创建掩码umask的影响，实际的权限为(mode &amp; ~umask</span><br><span class="line">&amp; 0777)</span><br><span class="line">返回值</span><br><span class="line">    成功：返回0</span><br><span class="line">    失败：返回-1，并设置errno</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// mkdir.c</span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    // ./mkdir dir mode</span><br><span class="line">    ARGS_CHECK(argc, 3);</span><br><span class="line">    </span><br><span class="line">    mode_t mode;</span><br><span class="line">    sscanf(argv[2], &quot;%o&quot;, &amp;mode);</span><br><span class="line">    // 创建的目录会受文件创建掩码的影响</span><br><span class="line">    int ret = mkdir(argv[1], mode);</span><br><span class="line">    ERROR_CHECK(ret, -1, &quot;mkdir&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除空目录</strong></p><p>rmdir 可以删除空目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int rmdir(const char *pathname);</span><br><span class="line">参数</span><br><span class="line">    pathname: 要删除的目录</span><br><span class="line">返回值</span><br><span class="line">    成功：返回0</span><br><span class="line">    失败：返回-1，并设置errno</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// rmdir.c</span><br><span class="line">#include &lt;func.h&gt;</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    // ./rmdir dir</span><br><span class="line">    ARGS_CHECK(argc, 2);</span><br><span class="line">    </span><br><span class="line">    int ret = rmdir(argv[1]); // 注意：rmdir 只能删除空目录</span><br><span class="line">    ERROR_CHECK(ret, -1, &quot;rmdir&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目录流"><a href="#目录流" class="headerlink" title="目录流"></a>目录流</h3><p>使用目录流，可以查看目录中的内容。在讲目录流之前，我们一起来回顾一下流模型：”流”类似”水流”，顺序访问流中的数据时，程序员是不需要 care 位置的。前面我们学习了文件流，文件流中的基本单位是字符或字节。</p><p><strong>目录流</strong> <strong>VS</strong> <strong>文件流</strong></p><table><thead><tr><th align="center"><strong>文件流</strong></th><th align="center"><strong>目录流</strong></th></tr></thead><tbody><tr><td align="center">fopen</td><td align="center">opendir</td></tr><tr><td align="center">fclose</td><td align="center">closedir</td></tr><tr><td align="center">fread</td><td align="center">readdir</td></tr><tr><td align="center">fwrite</td><td align="center">×</td></tr><tr><td align="center">ftell</td><td align="center">telldir</td></tr><tr><td align="center">fseek</td><td align="center">seekdir</td></tr><tr><td align="center">rewind</td><td align="center">rewinddir</td></tr></tbody></table><p>opendir 可以打开一个目录，得到一个指向目录流的指针 DIR*。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">DIR *opendir(const char *name);</span><br><span class="line">参数</span><br><span class="line">    name: 目录路径</span><br><span class="line">返回值</span><br><span class="line">    成功：返回指向目录流的指针。</span><br><span class="line">   失败：返回NULL，并设置errno。</span><br></pre></td></tr></table></figure><p>closedir 关闭目录流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">int closedir(DIR *dirp);</span><br><span class="line">参数</span><br><span class="line">    dirp: 指向目录流的指针</span><br><span class="line">返回值</span><br><span class="line">    成功：返回0</span><br><span class="line">    失败：返回-1，并设置errno</span><br></pre></td></tr></table></figure><p>readdir 读目录流，得到指向下一个目录项的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">struct dirent* readdir(DIR *dirp);</span><br><span class="line">参数</span><br><span class="line">    dirp: 指向目录流的指针</span><br><span class="line">返回值</span><br><span class="line"> 成功：返回指向结构体dirent的指针；如果读到流的末尾，返回NULL, 不改变errno的</span><br><span class="line">值。</span><br><span class="line">    失败：返回NULL，并设置errno</span><br><span class="line">        </span><br><span class="line">结构体dirent的定义如下：   // dirent: directory entry</span><br><span class="line"> struct dirent &#123;</span><br><span class="line"> ino_t d_ino;       /* inode编号 */</span><br><span class="line"> off_t d_off;      </span><br><span class="line">       unsigned short d_reclen;    /* 结构体的长度(d_name在有些实现上是一个</span><br><span class="line">可变长数组) */</span><br><span class="line">     unsigned char  d_type;      /* 文件的类型 */</span><br><span class="line">       char   d_name[256]; /* 文件名 */</span><br><span class="line"> &#125;;</span><br><span class="line"> d_type的可选值如下：</span><br><span class="line">     DT_BLK      This is a block device.</span><br><span class="line"> DT_CHR      This is a character device.</span><br><span class="line">        DT_DIR      This is a directory.</span><br><span class="line">       DT_FIFO     This is a named pipe (FIFO).</span><br><span class="line">        DT_LNK      This is a symbolic link.</span><br><span class="line">        DT_REG      This is a regular file.</span><br><span class="line">        DT_SOCK     This is a UNIX domain socket.</span><br><span class="line">        DT_UNKNOWN  The file type could not be determined.</span><br></pre></td></tr></table></figure><p>seekdir 可以移动目录流中的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">void seekdir(DIR *dirp, long loc);</span><br><span class="line">参数</span><br><span class="line">   dirp: 目录流</span><br><span class="line">    loc:  位置，是前面调用telldir函数的返回值。</span><br><span class="line">返回值</span><br><span class="line">    void</span><br></pre></td></tr></table></figure><p>telldir ：返回目录流中现在的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">long telldir(DIR *dirp);</span><br><span class="line">参数</span><br><span class="line">    dirp: 目录流</span><br><span class="line">返回值</span><br><span class="line">   成功：返回目录流中现在的位置。</span><br><span class="line">    失败：返回-1，并设置errno。</span><br></pre></td></tr></table></figure><p>rewinddir ：重置目录流，即移动到目录流的起始位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">void rewinddir(DIR *dirp)</span><br><span class="line">参数</span><br><span class="line">    dirp: 目录流</span><br><span class="line">返回值</span><br><span class="line">    void</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;func.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    DIR* pdir = opendir(&quot;.&quot;);</span><br><span class="line">    ERROR_CHECK(pdir, NULL, &quot;opendir&quot;);</span><br><span class="line">    </span><br><span class="line">    long loc = telldir(pdir);</span><br><span class="line">    struct dirent* pdirent;</span><br><span class="line">    errno = 0;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        // 事先记录目录流的位置</span><br><span class="line">        long tmploc = telldir(pdir);</span><br><span class="line">        pdirent = readdir(pdir);</span><br><span class="line">        if (pdirent == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">       &#125;</span><br><span class="line">        printf(&quot;%s &quot;, pdirent-&gt;d_name);</span><br><span class="line">        if (strcmp(pdirent-&gt;d_name, &quot;Makefile&quot;) == 0) &#123;</span><br><span class="line">            loc = tmploc;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    // 判断是否发生了错误</span><br><span class="line">    if (errno != 0) &#123;</span><br><span class="line">        perror(&quot;readdir&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">   &#125;</span><br><span class="line">    printf(&quot;-------------------------\n&quot;);</span><br><span class="line">    seekdir(pdir, loc);</span><br><span class="line">    pdirent = readdir(pdir);</span><br><span class="line">    puts(pdirent-&gt;d_name);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;--------------------------\n&quot;);</span><br><span class="line">    </span><br><span class="line">    rewinddir(pdir);</span><br><span class="line">    pdirent = readdir(pdir);</span><br><span class="line">    puts(pdirent-&gt;d_name);</span><br><span class="line">    // 关闭目录流</span><br><span class="line">    closedir(pdir);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：和 ls -l 命令不一样，目录项是没有通过任何方式进行排序的。</p><p><strong>课堂小练习</strong></p><ol><li>写一个小程序，实现青春版 tree 命令。效果如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./tree .</span><br><span class="line">.</span><br><span class="line"> dir1</span><br><span class="line"> text1</span><br><span class="line"> text2</span><br><span class="line"> dir2</span><br><span class="line"> file1</span><br><span class="line"> file2</span><br><span class="line"> dir3</span><br><span class="line"> a.txt</span><br><span class="line"> b.txt</span><br><span class="line">3 directories, 6 files</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// tree.c</span><br><span class="line">void dfs_print(const char* path, int width); /* width: 缩进的空格数目</span><br><span class="line">*/</span><br><span class="line">int directories = 0, files = 0;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // ./tree dir</span><br><span class="line">    ARGS_CHECK(argc, 2);</span><br><span class="line">    puts(argv[1]); // 打印目录的名字</span><br><span class="line">    dfs_print(argv[1], 4); // 递归打印每一个目录项</span><br><span class="line">    printf(&quot;\n%d directories, %d files\n&quot;, directories, files); //</span><br><span class="line">最后打印统计信息</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>写一个小程序，实现递归复制目录。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// copyDir.c</span><br><span class="line">void copyFile(const char* src, const char* dst);</span><br><span class="line">void copyDir(const char* src, const char* dst);</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    // ./copyDir src dst</span><br><span class="line">    ARGS_CHECK(argc, 3);</span><br><span class="line">    copyDir(argv[1], argv[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void copyFile(const char* src, const char* dst) &#123;</span><br><span class="line"> // 复制文件  </span><br><span class="line">&#125;</span><br><span class="line">void copyDir(const char* src, const char* dst) &#123;</span><br><span class="line">    // 创建dst目录</span><br><span class="line">    </span><br><span class="line">    // 打开src目录</span><br><span class="line">    // 遍历目录流</span><br><span class="line">    while(...) &#123;</span><br><span class="line">        // 忽略.和..</span><br><span class="line">        // 如果该目录项是目录，则调用copyDir递归复制</span><br><span class="line">        // 如果该目录项是文件，则调用copyFile复制文件</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    // 关闭目录流</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>写一个小程序，实现递归删除目录 (提示: man unlink )。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;func.h&gt;</span><br><span class="line">void deleteDir(const char* path);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // ./deleteDir dir</span><br><span class="line">    ARGS_CHECK(argc, 2);</span><br><span class="line">    deleteDir(argv[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void deleteDir(const char* path) &#123;</span><br><span class="line"> // 打开目录</span><br><span class="line">    // 遍历目录流，依次删除每一个目录项</span><br><span class="line">    while ((pdirent = readdir(pdir)) != NULL) &#123;</span><br><span class="line">        // 忽略.和..</span><br><span class="line">        // 如果该目录项是目录，则调用deleteDir递归删除</span><br><span class="line">        // 如果该目录项是文件，则调用unlink删除文件</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    // 目录为空了，可以删除该目录了</span><br><span class="line"> // 关闭目录流    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译工具链</title>
      <link href="/2023/08/06/bian-yi-gong-ju-lian/"/>
      <url>/2023/08/06/bian-yi-gong-ju-lian/</url>
      
        <content type="html"><![CDATA[<p>前面我们写程序的时候用的都是集成开发环境 (IDE: Integrated DevelopmentEnvironment)，集成开发环境可以极大地方便我们程序员编写程序，但是配置起来也相对麻烦。在 Linux 环境下，我们用的是编译工具链，又叫软件开发工具包(SDK:Software Development Kit)。Linux 环境下常见的编译工具链有：GCC 和 Clang，我们使用的是 GCC。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>gcc、g++分别是 gnu 下的 c 和 c++ 编译器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install gcc gdb # 安装gcc和gdb</span><br><span class="line"></span><br><span class="line">$ gcc -v # 查看gcc的版本</span><br></pre></td></tr></table></figure><p>对应的 gcc 命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i # -E激活预处理，生成预处理后的文件</span><br><span class="line">gcc -S hello.i -o hello.s # —S激活预处理和编译，生成汇编代码</span><br><span class="line">gcc -c hello.s -o hello.o # -c激活预处理、编译和汇编，生成目标文件</span><br><span class="line">gcc hello.o -o hello # 执行所有阶段，生成可执行程序</span><br></pre></td></tr></table></figure><p>一般来说会这样用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello # 编译链接，生成可执行程序hello</span><br></pre></td></tr></table></figure><h3 id="GCC其他选项"><a href="#GCC其他选项" class="headerlink" title="GCC其他选项"></a>GCC其他选项</h3><table><thead><tr><th align="center"><strong>选项</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">-Wall</td><td align="center">生成所有警告信息</td></tr><tr><td align="center">-O0,-O1,-O2,-O3</td><td align="center">编译器的4个优化级别，-O0表示不优化，-O1为缺省值，-O3的优化级别最高</td></tr><tr><td align="center">-g</td><td align="center">指示编译器在编译的时候产生调试相关的信息。(调试程序必须加上这个选项)</td></tr><tr><td align="center">-Dmacro</td><td align="center">相当于在文件的开头加了#define macro</td></tr><tr><td align="center">-Dmacro&#x3D;value</td><td align="center">相当于在文件的开头加了#define macro value</td></tr><tr><td align="center">-Idir</td><td align="center">对于 #include “file”，gcc&#x2F;g++会先在当前目录查找你所指定的头文件，如果没有找到，他会到系统的 include 目录找. 如果使用 -I 指定了目录，他会先在你所指定的目录查找，然后再按常规的顺序去找。对于#includ</td></tr></tbody></table><p>可以通过 cpp -v 命令查看系统的 include 目录。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>所谓<strong>条件编译</strong>，就是在<strong>预处理</strong>阶段决定包含还是排除某些程序片段。主要涉及以下预处理指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) #if [#elif] [#else] #endif</span><br><span class="line">2) #ifdef [#elif] [#else] #endif</span><br><span class="line">3) #ifndef [#elif] [#else] #endif</span><br></pre></td></tr></table></figure><ol><li>#if 指令的格式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当预处理器遇到 #if 指令时，会计算后面常量表达式的值。如果表达式的值为 0，则#if 与 #endif 之间的代码会在预处理阶段删除；否则，#if 与 #endif 之间的代码会被保留，交由编译器处理。</p><p>#if 指令常用于调试程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG 1</span><br><span class="line">...</span><br><span class="line">#if DEBUG</span><br><span class="line">    printf(&quot;i = %d\n&quot;, i);</span><br><span class="line"> printf(&quot;j = %d\n&quot;, j);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol start="2"><li>defined 是预处理器的一个运算符，它后面接标识符。如果标识符是一个定义过的</li></ol><p>宏则值为 1，否则值为 0。defined 运算符常和 #if 指令一起使用，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(DEBUG)</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>仅当 DEBUG 被定义成宏时，#if 和 #endif 之间的代码会保留到程序中。defined 后面的括号不是必须的，因此可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#if defined DEBUG</span><br></pre></td></tr></table></figure><p>defined 运算符仅检测 DEBUG 是否有被定义成宏，所以我们不需要给 DEBUG 赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br></pre></td></tr></table></figure><ol start="3"><li>#ifdef 的格式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当标识符有被定义成宏时，保留 #ifdef 与 #endif 之间的代码；否则，在预处理阶段删除 #ifdef 与 #endif 之间的代码。等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(标识符)</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol start="4"><li>#ifndef 的格式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef 标识符</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>它的作用恰恰与 #ifdef 相反：当标识符没有被定义成宏时，保留 #ifndef 与 #endif之间的代码。</p><h4 id="条件编译的作用"><a href="#条件编译的作用" class="headerlink" title="条件编译的作用"></a>条件编译的作用</h4><p>条件编译对于调试是非常方便的，但它的作用不仅限于此。下面是其它一些常见的应用：</p><p><strong>编写可移植的程序</strong></p><p>下面的例子会根据 WIN32、MAC_OS 或 LINUX 是否被定义为宏，而将对应的代码包含到程序中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if defined(WIN32)</span><br><span class="line">...</span><br><span class="line">#elif defined(MAC_OS)</span><br><span class="line">...</span><br><span class="line">#elif defined(LINUX)</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>为宏提供默认定义</strong></p><p>我们可以检测一个宏是否被定义了，如果没有，则提供一个默认的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef BUFFER_SIZE</span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>避免头文件重复包含</strong></p><p>多次包含同一个头文件，可能会导致编译错误(比如，头文件中包含类型的定义)。因此，我们应该避免重复包含头文件。使用 #ifndef 和 #define 可以轻松实现这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __WD_FOO_H</span><br><span class="line">#define __WD_FOO_H</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[25];</span><br><span class="line">    char gender;</span><br><span class="line">    int chinese;</span><br><span class="line">    int math;</span><br><span class="line">    int english;</span><br><span class="line">&#125; Student;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>临时屏蔽包含注释的代码</strong></p><p>我们不能用 &#x2F;<em>…</em>&#x2F; “注释掉” 已经包含 &#x2F;<em>…</em>&#x2F;注释的代码。但是我们可以用 #if 指令来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">包含/*...*/注释的代码</span><br><span class="line">#endif</span><br><span class="line">这种屏蔽方式，我们称之为&quot;条件屏蔽&quot;。</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>写程序难免会遇到 Bug，这时我们就需要 GDB 来对程序进行调试了。调试需要在编译的时候，加上一些调试相关的信息，也就是说，需要指定 -g 选项。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -g</span><br></pre></td></tr></table></figure><h3 id="进入GDB调试界面"><a href="#进入GDB调试界面" class="headerlink" title="进入GDB调试界面"></a>进入GDB调试界面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gdb foo</span><br><span class="line">$ gdb --args foo arg1 arg2 arg3</span><br><span class="line">当然，我们也可以先进入调试界面，然后再设置命令行参数，如下所示：</span><br><span class="line">$ gdb foo</span><br><span class="line">(gdb) set args arg1 arg2 arg3</span><br></pre></td></tr></table></figure><h3 id="调试界面"><a href="#调试界面" class="headerlink" title="调试界面"></a>调试界面</h3><p><strong>查看源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list # 下翻源代码</span><br><span class="line">(gdb) list - # 上翻源代码</span><br><span class="line">(gdb) list 20 # 查看20行附近的源代码</span><br><span class="line">(gdb) list main # 查看main函数附近的源代码</span><br><span class="line">(gdb) list scanner.c:20 # 查看scanner.c文件第20行附近的源代</span><br><span class="line">码</span><br><span class="line">(gdb) list scanner.c:scanToken # 查看scanner.c文件scanToken函数附</span><br><span class="line">近的源代码</span><br></pre></td></tr></table></figure><p><strong>设置断点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 20 # 在第20行设置断点</span><br><span class="line">(gdb) break main # 在main函数的开头设置断点</span><br><span class="line">(gdb) break scanner.c:20 # 在scanner.c文件的第20行设置断点</span><br><span class="line">(gdb) break scanner.c:scanToken # 在scanner.c文件的scanToken函数开</span><br><span class="line">头设置断点</span><br></pre></td></tr></table></figure><p><strong>查看断点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address           What</span><br><span class="line">1       breakpoint     keep y   0x0000555555554e1d in main at main.c:79</span><br><span class="line">2       breakpoint     keep y   0x0000555555555a99 in scanToken at</span><br><span class="line">scanner.c:282</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 Num 为断点的编号，Enb(enable)表示断点是否有效，What表示断点在源代码的哪个位置。</p><p><strong>删除断点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 2 # 删除2号断点</span><br><span class="line">(gdb) d # 删除所有断点</span><br></pre></td></tr></table></figure><p><strong>启动调试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r                     //run</span><br></pre></td></tr></table></figure><p><strong>继续</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c//continue</span><br></pre></td></tr></table></figure><p><strong>忽略断点n次</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ignore 1 10 # 忽略1号断点10次</span><br></pre></td></tr></table></figure><p><strong>单步调试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) step</span><br></pre></td></tr></table></figure><p><strong>跳出函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure><p><strong>逐过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n                    //next</span><br></pre></td></tr></table></figure><p><strong>监视</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print PI*r*r        </span><br></pre></td></tr></table></figure><p>我们可以用 display 命令自动展示表达式的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display r</span><br><span class="line">(gdb) display PI*r*r</span><br><span class="line">(gdb) info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y r</span><br><span class="line">2:   y PI*r*r</span><br><span class="line">(gdb) undisplay 2</span><br><span class="line">(gdb) undisplay</span><br><span class="line">Delete all auto-display expressions? (y or n)</span><br></pre></td></tr></table></figure><p>我们还可以通过命令查看参数和局部变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info args # 查看函数的参数</span><br><span class="line">(gdb) info locals # 查看函数所有局部变量的值</span><br></pre></td></tr></table></figure><p><strong>查看内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> x/nFU</span><br><span class="line"> 其中, n为一个整数，表示查看n个单元的内存</span><br><span class="line"> F表示输出格式：</span><br><span class="line"> 常用的输出格式有：</span><br><span class="line"> o(octal),</span><br><span class="line"> x(hex),</span><br><span class="line"> d(decimal),</span><br><span class="line"> u(unsigned decimal),</span><br><span class="line"> t(binary),</span><br><span class="line"> f(float),</span><br><span class="line"> c(char),</span><br><span class="line"> ...</span><br><span class="line"> 默认输出格式为x(hex)。</span><br><span class="line"> U表示内存单元：</span><br><span class="line"> b(byte), h(halfword, 2 bytes), w(word, 4 bytes), g(giant, 8</span><br><span class="line">bytes)</span><br><span class="line"> 默认单位为w(word)</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/4dw arr</span><br><span class="line">0x7fffffffe3a0: 0 1 2 3</span><br><span class="line">(gdb) x/4xb &amp;i</span><br><span class="line">0x7fffffffe38c: 0x37 0x25 0x00 0x00 # 其中i=9527</span><br></pre></td></tr></table></figure><p><strong>退出GDB</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure><h3 id="调试coredump文件"><a href="#调试coredump文件" class="headerlink" title="调试coredump文件"></a>调试coredump文件</h3><p>通常情况下，程序异常终止时，会产生 Coredump 文件。Coredump 文件类似飞机上的”黑匣子”，它会保留程序”失事”瞬间的一些信息，通常包含寄存器的状态、栈调用情况等。Coredump 文件常用于辅助分析和 Debug。</p><p><strong>查看系统是否允许生成Coredump文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">core file size         (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">...</span><br><span class="line">$ ulimit -c unlimited # 将core文件的大小临时设置为不受限制</span><br></pre></td></tr></table></figure><p><strong>设置Coredump文件的格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/sysctl.conf </span><br><span class="line"> kernel.core_pattern = %e_core_%s_%t # %e:executable-name,</span><br><span class="line">%s:signal, %t:time</span><br><span class="line">$ sudo sysctl -p # 让配置生效</span><br></pre></td></tr></table></figure><p><strong>使用Coredump文件调试程序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int div(int div_i, int div_j) &#123;</span><br><span class="line">    int a4, b4;</span><br><span class="line">    char *c4;</span><br><span class="line">    </span><br><span class="line">    a4 = div_i + 3;</span><br><span class="line">    b4 = div_j + 3;</span><br><span class="line">    c4 = &quot;div function&quot;;</span><br><span class="line">    return (div_i / div_j);</span><br><span class="line">&#125;</span><br><span class="line">int sub(int sub_i, int sub_j) &#123;</span><br><span class="line">    int a3, b3;</span><br><span class="line">    char *c3;</span><br><span class="line">    a3 = sub_i + 2;</span><br><span class="line">    b3 = sub_j + 2;</span><br><span class="line">    c3 = &quot;sub function&quot;;</span><br><span class="line">    div(a3, 0);   // Error: divided by 0!</span><br><span class="line">    return (sub_i - sub_j);</span><br><span class="line">&#125;</span><br><span class="line">int add(int add_i, int add_j) &#123;</span><br><span class="line">    int a2, b2;</span><br><span class="line">    char *c2;</span><br><span class="line">    a2 = add_i + 1;</span><br><span class="line">    b2 = add_j + 1;</span><br><span class="line">    c2 = &quot;add function&quot;;</span><br><span class="line">    sub(a2, b2);</span><br><span class="line">    return (add_i + add_j);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    int a1, b1;</span><br><span class="line">    char *c1;</span><br><span class="line">    a1 = 1;</span><br><span class="line">    b1 = 0;</span><br><span class="line">    c1 = &quot;main function&quot;;</span><br><span class="line">    add(a1, b1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test -g # 生成可执行程序test</span><br><span class="line">$ ./test # 运行test</span><br><span class="line">$ gdb test test_core_8_1679196427 # 使用Coredump文件调试程序</span><br><span class="line">...</span><br><span class="line">[New LWP 5036]</span><br><span class="line">Core was generated by `./test&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0 0x0000564d0188a645 in div (div_i=4, div_j=0) at test.c:9</span><br><span class="line">9   return (div_i / div_j);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt # backtrace,查看栈调用情况</span><br><span class="line">#0 0x0000564d0188a645 in div (div_i=4, div_j=0) at test.c:9</span><br><span class="line">#1 0x0000564d0188a684 in sub (sub_i=2, sub_j=1) at test.c:19</span><br><span class="line">#2 0x0000564d0188a6c6 in add (add_i=1, add_j=0) at test.c:31</span><br><span class="line">#3 0x0000564d0188a707 in main (argc=1, argv=0x7ffc5cf053d8) at</span><br><span class="line">test.c:44</span><br><span class="line">(gdb) frame 3 # 查看#3栈帧的情况</span><br><span class="line">#3 0x0000564d0188a707 in main (argc=1, argv=0x7ffc5cf053d8) at</span><br><span class="line">test.c:44</span><br><span class="line">44   add(a1, b1);</span><br><span class="line">(gdb) info args # 查看参数的值</span><br><span class="line">argc = 1</span><br><span class="line">argv = 0x7ffc5cf053d8</span><br><span class="line">(gdb) info locals # 查看局部变量的值</span><br><span class="line">a1 = 1</span><br><span class="line">b1 = 0</span><br><span class="line">c1 = 0x564d0188a7bb &quot;main function&quot;</span><br><span class="line">(gdb) info registers # 查看寄存器的值</span><br><span class="line">rax           0x4 4</span><br><span class="line">rbx           0x0 0</span><br><span class="line">rcx           0x564d0188a710 94888738203408</span><br><span class="line">rdx           0x0 0</span><br><span class="line">rsi           0x0 0</span><br><span class="line">rdi           0x4 4</span><br><span class="line">rbp           0x7ffc5cf052f0 0x7ffc5cf052f0</span><br><span class="line">rsp           0x7ffc5cf052d0 0x7ffc5cf052d0</span><br></pre></td></tr></table></figure><h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><p>静态库之所以称为静态，是因为它会在链接阶段打包到可执行程序中。静态库有如下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 静态库对函数的链接是在链接阶段完成的。</span><br><span class="line">2. 程序在运行时，与静态库再无瓜葛。移植方便。</span><br><span class="line">3. 浪费空间，每一个进程中都有静态库的一个副本。</span><br><span class="line">4. 对程序的更新，部署，发布不友好(需要所有用户重新下载安装新的可执行程序)。</span><br></pre></td></tr></table></figure><p>动态库之所以称为动态，是因为它在链接阶段并不会打包到可执行程序中，而是在程序运行的时候才加载的。动态库有如下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 动态库对函数的链接是在运行时完成的。</span><br><span class="line">2. 动态库可以在进程之间共享(所以，动态库又被称为共享库)。</span><br><span class="line">3. 对程序的更新，部署，发布友好(因为，我们只要更新动态库就好了)。</span><br><span class="line">4. 程序在运行时，依赖动态库。不方便移植。</span><br></pre></td></tr></table></figure><p><strong>生成静态库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 生成目标文件</span><br><span class="line">$ gcc -c add.c</span><br><span class="line">$ gcc -c sub.c</span><br><span class="line">$ gcc -c mul.c</span><br><span class="line">$ gcc -c div.c</span><br><span class="line">2. 把目标文件打包成静态库</span><br><span class="line">$ ar crsv libalgs.a add.o sub.o mul.o div.o # 静态库一般以.a结尾,</span><br><span class="line">库的名字为algs</span><br><span class="line">3. 将生成的静态库移动到/usr/lib目录下  </span><br><span class="line">$ mv libalgs.a /usr/lib</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -o main -lalgs # 将静态库链接到程序</span><br><span class="line">$ ./main # 执行程序</span><br><span class="line">add(7, 3)=10</span><br><span class="line">sub(7, 3)=4</span><br><span class="line">mul(7, 3)=21</span><br><span class="line">div(7, 3)=2</span><br><span class="line">$ sudo rm /usr/lib/libalgs.a # 删除静态库</span><br><span class="line">(在/usr/lib目录下删除内容，请额外小心!)</span><br><span class="line">$ ./main # 程序依然能够运行</span><br><span class="line">add(7, 3)=10</span><br><span class="line">sub(7, 3)=4</span><br><span class="line">mul(7, 3)=21</span><br><span class="line">div(7, 3)=2</span><br></pre></td></tr></table></figure><p><strong>生成动态库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 生成目标文件，需要加上-fpic选项</span><br><span class="line">$ gcc -c add.c -fpic</span><br><span class="line">$ gcc -c sub.c -fpic</span><br><span class="line">$ gcc -c mul.c -fpic</span><br><span class="line">$ gcc -c div.c -fpic</span><br><span class="line">2. 把目标文件打包成动态库</span><br><span class="line">$ gcc -shared add.o sub.o mul.o div.o -o libalgs.so</span><br><span class="line">3. 将生成的动态库移动到/usr/lib目录下</span><br><span class="line">$ mv libalgs.so /usr/lib</span><br></pre></td></tr></table></figure><p>编写程序，引用 algs 库中的函数 (这里我们沿用上面的 main.c)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -o main -lalgs # 将动态库链接到程序</span><br><span class="line">$ ./main # 执行程序</span><br><span class="line">add(7, 3)=10</span><br><span class="line">sub(7, 3)=4</span><br><span class="line">mul(7, 3)=21</span><br><span class="line">div(7, 3)=2</span><br><span class="line">$ sudo rm /usr/lib/libalgs.so # 删除动态库</span><br><span class="line">$ ./main # 程序不再能运行</span><br><span class="line">./main: error while loading shared libraries: libalgs.so: cannot open</span><br><span class="line">shared object file: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 生成目标文件，需要加上-fpic选项</span><br><span class="line">$ gcc -c add.c -fpic</span><br><span class="line">$ gcc -c sub.c -fpic</span><br><span class="line">$ gcc -c mul.c -fpic</span><br><span class="line">$ gcc -c div.c -fpic</span><br><span class="line">2. 把目标文件打包成动态库</span><br><span class="line">$ gcc -shared add.o sub.o mul.o div.o -o libalgs.so.0.0.2</span><br><span class="line">4 Ma ke fi l e</span><br><span class="line">什么是 Makefile？很多 Windows 程序员都不知道这个东西，因为 Windows 的集成开</span><br><span class="line">发环境帮你做了相关的工作，但要成为一个好的和专业的程序员，Makefile 还是很有</span><br><span class="line">必要学习的。</span><br><span class="line">Makefile 定义了整个工程的编译规则。一个工程中的源文件不计其数，哪些文件需要</span><br><span class="line">先编译，哪些文件要后编译，哪些文件需要重新编译...，这些规则我们都可以在</span><br><span class="line">Makefile 中定义。Makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一</span><br><span class="line">个 make 命令，就可以构建整个工程，极大的提高了软件开发的效率。make 是一个</span><br><span class="line">解释执行 Makefile 文件的工具。</span><br><span class="line">而且 Makefile 采用的是&quot;增量编译&quot;，也就是说，我们只编译那些更新过的和新增的源</span><br><span class="line">文件；那些没修改过的源文件，是不会重新编译的。这极大的节省了编译的时间，也</span><br><span class="line">节省了程序员摸鱼的时间( ╯□╰ )...</span><br><span class="line">3. 将生成的动态库移动到/usr/lib目录下</span><br><span class="line">$ sudo mv libalgs.so.0.0.2 /usr/lib</span><br><span class="line">4. cd 到/usr/lib目录</span><br><span class="line">$ cd /usr/lib</span><br><span class="line">5. 创建符号链接，将其指向新的动态库 # 这样就不用覆盖旧的库</span><br><span class="line">了，方便以后回退~</span><br><span class="line">$ sudo ln -s libalgs.so.0.0.2 libalgs.so</span><br><span class="line">6. cd回来</span><br><span class="line">$ cd -</span><br><span class="line">7. 执行程序</span><br><span class="line">$ ./main</span><br><span class="line">I love xixi</span><br><span class="line">add(7, 3)=10</span><br><span class="line">I love xixi</span><br><span class="line">sub(7, 3)=4</span><br><span class="line">I love xixi</span><br><span class="line">mul(7, 3)=21</span><br><span class="line">I love xixi</span><br><span class="line">div(7, 3)=2</span><br></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><strong>Makefile</strong> <strong>定义了整个工程的编译规则</strong>。一个工程中的源文件不计其数，哪些文件需要先编译，哪些文件要后编译，哪些文件需要重新编译…，这些规则我们都可以在Makefile 中定义。Makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，就可以构建整个工程，极大的提高了软件开发的效率。make 是一个解释执行 Makefile 文件的工具。</p><p>而且 Makefile 采用的是”增量编译”，也就是说，我们只编译那些更新过的和新增的源文件；那些没修改过的源文件，是不会重新编译的。这极大的节省了编译的时间，也节省了程序员摸鱼的时间( ╯□╰ )…</p><p>相对来说，编译过程是很耗时的，编译 Linux 内核往往需要好几个小时。而链接过程则非常迅速。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main: main.o add.o sub.o mul.o div.o</span><br><span class="line"> gcc main.o add.o sub.o mul.o div.o -o main</span><br><span class="line">main.o: main.c algs.h</span><br><span class="line"> gcc -c main.c -Wall -g</span><br><span class="line">add.o: add.c algs.h</span><br><span class="line"> gcc -c add.c -Wall -g</span><br><span class="line">sub.o: sub.c algs.h</span><br><span class="line"> gcc -c sub.c -Wall -g</span><br><span class="line">mul.o: mul.c algs.h</span><br><span class="line"> gcc -c mul.c -Wall -g</span><br><span class="line">div.o: div.c algs.h</span><br><span class="line"> gcc -c div.c -Wall -g</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><p><strong>规则</strong></p><p>Makefile 的核心就是规则，一个规则是由三部分组成的：目标(target)，依赖(prerequisites)以及命令(commands)。其格式如下：</p><p>规则定义了文件之间的依赖关系。**说得更直白一点，make其实就是一个管理文件之间依赖的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 如果target文件不存在，执行commands.</span><br><span class="line">2. 如果prerequisites中有一个文件比target文件更新，也要执行commands.</span><br></pre></td></tr></table></figure><h3 id="make时如何工作的"><a href="#make时如何工作的" class="headerlink" title="make时如何工作的"></a>make时如何工作的</h3><p>make 会递归地去查找文件之间的依赖关系，直到最终生成要执行的目标。在查找的过程中，如果出现错误，比如最后依赖的文件不存在，那么 make 就会直接退出，并报错。</p><p>如果我们修改了某个文件，比如 add.c，然后重新执行 make 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">gcc -c add.c -Wall -g</span><br><span class="line">gcc main.o add.o sub.o mul.o div.o -o main</span><br></pre></td></tr></table></figure><p>从上面我们可以看到，我们只是重新编译了 add.c 文件，并重新链接生成可执行程序main，这就是所谓的”增量编译”。</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>make 只管理文件之间的依赖关系，如果目标不存在，则执行后面定义的命令。利用这个特性，我们可以定义一些伪目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main: main.o add.o sub.o mul.o div.o</span><br><span class="line"> gcc main.o add.o sub.o mul.o div.o -o main</span><br><span class="line">main.o: main.c algs.h</span><br><span class="line"> gcc -c main.c -Wall -g</span><br><span class="line">add.o: add.c algs.h</span><br><span class="line"> gcc -c add.c -Wall -g</span><br><span class="line">sub.o: sub.c algs.h</span><br><span class="line"> gcc -c sub.c -Wall -g</span><br><span class="line"> mul.o: mul.c algs.h</span><br><span class="line"> gcc -c mul.c -Wall -g</span><br><span class="line">div.o: div.c algs.h</span><br><span class="line"> gcc -c div.c -Wall -g</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line"> rm -f main main.o add.o sub.o mul.o div.o</span><br><span class="line">rebuild: clean main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean # 清除可执行程序和所有的目标文件，make可以指定要执行的</span><br><span class="line">目标。</span><br><span class="line">$ make rebuild # 先清除可执行程序和所有的目标文件，然后再构建main。</span><br></pre></td></tr></table></figure><p>但是这样写 Makefile，有一个弊端：如果存在名字为 clean 和 rebuild 的文件，那么make clean 和 make rebuild 就不起作用了。将 clean 和 rebuild 添加到 .PHONY 的序列中，可以避免这种情况发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> rm -f main main.o add.o sub.o mul.o div.o</span><br><span class="line">rebuild: clean main</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在声明时需要赋初始值；使用时，需要给在变量名前加上$符号，如果变量名包含多个字符，我们应该用小括号 () 或大括号 {} 把变量括起来。</p><p><strong>自定义变量</strong></p><p>自定义变量，顾名思义，就是程序员自己定义的变量。引入自定义变量后，我们可以将上面的 Makefile 改写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Objs := main.o add.o sub.o mul.o div.o</span><br><span class="line">Out := main</span><br><span class="line">$(Out): $(Objs)</span><br><span class="line"> gcc $(Objs) -o $(Out)</span><br><span class="line">main.o: main.c algs.h</span><br><span class="line"> gcc -c main.c -Wall -g</span><br><span class="line">add.o: add.c algs.h</span><br><span class="line"> gcc -c add.c -Wall -g</span><br><span class="line">sub.o: sub.c algs.h</span><br><span class="line"> gcc -c sub.c -Wall -g</span><br><span class="line">mul.o: mul.c algs.h</span><br><span class="line"> gcc -c mul.c -Wall -g</span><br><span class="line">div.o: div.c algs.h</span><br><span class="line"> gcc -c div.c -Wall -g</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> rm -f $(Out) $(Objs)</span><br><span class="line">rebuild: clean $(Out)</span><br></pre></td></tr></table></figure><p><strong>预定义变量</strong></p><p>预定义变量，即预先定义好的变量，这些变量的含义是事先确定的。</p><table><thead><tr><th align="center"><strong>变量名</strong></th><th align="center"><strong>功能</strong></th><th align="center"><strong>默认含义</strong></th></tr></thead><tbody><tr><td align="center">AR</td><td align="center">打包库文件</td><td align="center">ar</td></tr><tr><td align="center">AS</td><td align="center">汇编程序</td><td align="center">as</td></tr><tr><td align="center">CC</td><td align="center">C编译器</td><td align="center">cc</td></tr><tr><td align="center">CPP</td><td align="center">C预编译器</td><td align="center">$(CC) -E</td></tr><tr><td align="center">CXX</td><td align="center">C++编译器</td><td align="center">g++</td></tr><tr><td align="center">RM</td><td align="center">删除</td><td align="center">rm –f</td></tr><tr><td align="center">ARFLAGS</td><td align="center">库选项</td><td align="center">无</td></tr><tr><td align="center">ASFLAGS</td><td align="center">汇编选项</td><td align="center">无</td></tr><tr><td align="center">CFLAGS</td><td align="center">C编译器选项</td><td align="center">无</td></tr><tr><td align="center">CPPFLAGS</td><td align="center">C预编译器选项</td><td align="center">无</td></tr><tr><td align="center">CXXFLAGS</td><td align="center">C++编译器选项</td><td align="center">无</td></tr></tbody></table><p>引入预定义变量后，我们可以将上面的 Makefile 改写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Objs := main.o add.o sub.o mul.o div.o</span><br><span class="line">Out := main</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line">$(Out): $(Objs)</span><br><span class="line"> $(CC) $(Objs) -o $(Out)</span><br><span class="line">main.o: main.c algs.h</span><br><span class="line"> $(CC) -c main.c $(CFLAGS)</span><br><span class="line">add.o: add.c algs.h</span><br><span class="line"> $(CC) -c add.c $(CFLAGS)</span><br><span class="line">sub.o: sub.c algs.h</span><br><span class="line"> $(CC) -c sub.c $(CFLAGS)</span><br><span class="line">mul.o: mul.c algs.h</span><br><span class="line"> $(CC) -c mul.c $(CFLAGS)</span><br><span class="line">div.o: div.c algs.h</span><br><span class="line"> $(CC) -c div.c $(CFLAGS)</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> $(RM) $(Out) $(Objs)</span><br><span class="line">rebuild: clean $(Out)</span><br></pre></td></tr></table></figure><p><strong>规则中的特殊变量</strong></p><p>规则中的特殊变量就是某些具有特殊含义的变量，它的含义和当前规则有关。</p><table><thead><tr><th align="center"><strong>变量名</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">目标</td></tr><tr><td align="center">$&lt;</td><td align="center">第一个依赖文件</td></tr><tr><td align="center">$^</td><td align="center">所有依赖文件，以空格分隔</td></tr><tr><td align="center">$?</td><td align="center">所有日期新于target的依赖文件</td></tr></tbody></table><p>引入自动变量后，我们可以将上面的 Makefile 改写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Objs := main.o add.o sub.o mul.o div.o</span><br><span class="line">Out := main</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line">$(Out): $(Objs)</span><br><span class="line"> $(CC) $^ -o $@</span><br><span class="line"> main.o: main.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">add.o: add.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">sub.o: sub.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">mul.o: mul.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">div.o: div.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> $(RM) $(Out) $(Objs)</span><br><span class="line">rebuild: clean $(Out)</span><br></pre></td></tr></table></figure><h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h3><p>模式规则类似于普通规则。只是在模式规则中，target 需要包含模式字符”%”，”%” 可以匹配任何非空字符串。规则的依赖中同样可以使用”%”，依赖中模式字符”%”的取值和目标中的”%”的取值一样。</p><p>(注：模式规则，就是说我们只要定义规则的模式即可。make 会根据规则的模式自动生成具体的规则)。</p><p>有了模式规则后，我们可以这样写 Makefile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Objs := main.o add.o sub.o mul.o div.o</span><br><span class="line">Out := main</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line">$(Out): $(Objs) # Objs := main.o add.o sub.o mul.o</span><br><span class="line">div.o</span><br><span class="line"> $(CC) $^ -o $@</span><br><span class="line"> %.o: %.c algs.h # 这里应用了Makefile的隐式推导，%.o是与</span><br><span class="line">上一个规则的依赖进行匹配，即$(Objs)</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> $(RM) $(Out) $(Objs)</span><br><span class="line">rebuild: clean $(Out)</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><function>为函数名，<arguments>为参数列表。参数之间以逗号,分隔，而函数名和</p><p>参数之间以”空格”分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br><span class="line">或</span><br><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>通配符函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> $(wildcard &lt;pattern&gt;)</span><br><span class="line">作用：</span><br><span class="line"> 查找符合&lt;pattern&gt;的所有文件列表</span><br><span class="line">返回值：</span><br><span class="line"> 返回所有符合&lt;pattern&gt;的文件名，文件名之间以空格分隔。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Srcs := $(wildcard *.c)</span><br><span class="line"># 查找当前目录下，所有以.c结尾的文件名。将文件名以空格分隔，并赋值给变量Srcs。</span><br></pre></td></tr></table></figure><p><strong>模式替换函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br><span class="line">作用：</span><br><span class="line"> 查找&lt;text&gt;中符合模式&lt;pattern&gt;的单词(单词以空白字符分隔)，将其替换为</span><br><span class="line">&lt;replacement&gt;。</span><br><span class="line"> 注：&lt;pattern&gt;可以包括通配符%，表示任意长度的字符串。如果&lt;replacement&gt;中也含</span><br><span class="line">有%，那么，&lt;replacement&gt;中的%所代表的字符串和&lt;pattern&gt;中%所代表的字符串相同。</span><br><span class="line">返回值：</span><br><span class="line"> 返回替换后的字符串</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c, %.o, foo.c.c bar.c)</span><br><span class="line"># 将字符串 foo.c.c bar.c 中符合模式 %.c 的单词替换成 %.o，返回结果为 foo.c.o</span><br><span class="line">bar.o</span><br></pre></td></tr></table></figure><p>引入内置函数后，我们可以将上面的 Makefile 改写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Srcs := $(wildcard *.c)</span><br><span class="line">Objs := $(patsubst %.c, %.o, $(Srcs))</span><br><span class="line">Out := main</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line">$(Out): $(Objs)</span><br><span class="line"> $(CC) $^ -o $@</span><br><span class="line">%.o: %.c algs.h</span><br><span class="line"> $(CC) -c $&lt; $(CFLAGS)</span><br><span class="line">.PHONY: clean rebuild</span><br><span class="line">clean:</span><br><span class="line"> $(RM) $(Out) $(Objs)</span><br><span class="line">rebuild: clean $(Out)</span><br></pre></td></tr></table></figure><p><strong>小练习</strong></p><p>请书写 Makefile 完成下面任务：在一个目录有多个.c文件，将每一个.c文件单独编译链接生成一个可执行程序 (注意，尽量提升通用性，而且要有 clean 和 rebuild 的功能)。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2023/07/28/vim/"/>
      <url>/2023/07/28/vim/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h1><p>Vim(Vi improved) 是从 Vi 发展出来的一个文本编辑器。Vim 在程序员中使用地非常广泛，和 Emacs 并称为类 Unix 系统用户最喜欢的文本编辑器。事实上，这两大编辑神器之间的圣战一直没停歇过。</p><span id="more"></span><p><strong>Vim</strong> <strong>的设计理念是</strong> <strong>Composability</strong> (<strong>组合</strong>):</p><p>例如在 Vim 中，”d” 表示删除，”j” 移动到下一行，组合 “dj” 表示删除当前行和下一行；”^” 代表行首，故组合 “d^” 表示删除到行首；”$” 代表行尾，”d$” 表示删除到行尾。而且我们还可以指定命令重复的次数：”dd” 表示删除光标所在行，”2dd” 或”d2d” 表示连续删除两行，效果和 “dj” 一致。</p><p>Vim 是一种模式编辑器，它与我们熟悉的”所见即所得”的编辑器不太一样。Vim 在不同模式下有不同的功能，这也是 Vim 之所有这么 NB 的原因之一。Vim 有多种模式，最常用的是：普通(命令)模式、插入(编辑)模式和视图模式。这些模式之间可以相互转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 在光标前面插入</span><br><span class="line">I: 在行首插入</span><br><span class="line">a: 在光标后面插入</span><br><span class="line">A: 在行尾插入</span><br><span class="line">o: 在下面另起一行，并在行首插入</span><br><span class="line">O: 在上面另起一行，并在行首插入</span><br><span class="line">v: 进入行选模式</span><br><span class="line">[ctrl]+v: 进入竖选模式</span><br></pre></td></tr></table></figure><h2 id="1-1普通模式"><a href="#1-1普通模式" class="headerlink" title="1.1普通模式"></a>1.1普通模式</h2><p>普通模式又叫命令模式，顾名思义，这种模式就是用来执行各种命令的。命令可以分为长命令和短命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">长命令：以:开头，以[Enter]结尾的命令。比如，:wq[Enter]</span><br><span class="line">短命令：如a,o,i...</span><br></pre></td></tr></table></figure><p><strong>移动光标</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">往左移动一个字符</td></tr><tr><td align="center">j</td><td align="center">往下移动一个字符</td></tr><tr><td align="center">k</td><td align="center">往上移动一个字符</td></tr><tr><td align="center">l</td><td align="center">往右移动一个字符</td></tr><tr><td align="center">[n]-</td><td align="center">往上移动n行</td></tr><tr><td align="center">[n]+</td><td align="center">往下移动n行</td></tr><tr><td align="center">:[n] 或 [n]G</td><td align="center">移动到第n行</td></tr><tr><td align="center">gg</td><td align="center">移动到文件的第一行</td></tr><tr><td align="center">G</td><td align="center">移动到文件的最后一行</td></tr><tr><td align="center">^</td><td align="center">移动到这一行的第一个非空白字符处</td></tr><tr><td align="center">$</td><td align="center">移动到行尾</td></tr><tr><td align="center">w</td><td align="center">下一个单词的词首</td></tr><tr><td align="center">b</td><td align="center">上一个单词的词首</td></tr><tr><td align="center">t)</td><td align="center">向后查找，将光标移动到)的前一个字符</td></tr><tr><td align="center">T”</td><td align="center">向前查找，将光标移动到”的后一个字符</td></tr><tr><td align="center">f)</td><td align="center">向后查找，将光标移动到)</td></tr><tr><td align="center">F”</td><td align="center">向前查找，将光标移动到”</td></tr></tbody></table><p><strong>删除文本</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除一个字符</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词</td></tr><tr><td align="center">[n]dw 或 d[n]w</td><td align="center">删除n个单词</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">[n]dd 或 d[n]d</td><td align="center">删除n行</td></tr><tr><td align="center">:[m],[n]d</td><td align="center">删除[m,n]行</td></tr><tr><td align="center">d^</td><td align="center">删除到行首</td></tr><tr><td align="center">d$</td><td align="center">删除到行尾</td></tr><tr><td align="center">dt)</td><td align="center">删除到)</td></tr><tr><td align="center">dt”</td><td align="center">删除到”</td></tr></tbody></table><p><strong>粘贴，撤销和恢复</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">p 或 P(paste)</td><td align="center">粘贴</td></tr><tr><td align="center">u(undo)</td><td align="center">撤销</td></tr><tr><td align="center">[ctrl] + r(recovery)</td><td align="center">恢复</td></tr></tbody></table><p><strong>复制文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">[n]yy 或 y[n]y</td><td align="center">复制n行</td></tr><tr><td align="center">:[m],[n]y</td><td align="center">复制[m,n]行</td></tr><tr><td align="center">yw</td><td align="center">复制一个单词</td></tr><tr><td align="center">[n]yw 或 y[n]w</td><td align="center">复制n个单词</td></tr><tr><td align="center">yt)</td><td align="center">复制到)</td></tr><tr><td align="center">yt”</td><td align="center">复制到”</td></tr></tbody></table><p><strong>修改文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">cc 或 S</td><td align="center">删除当前行，并进入编辑模式</td></tr><tr><td align="center">[n]cc 或 [n]S</td><td align="center">删除n行，并进入编辑模式</td></tr><tr><td align="center">cw</td><td align="center">删除一个单词，并进入编辑模式</td></tr><tr><td align="center">[n]cw 或 c[n]w</td><td align="center">删除n个单词，并进入编辑模式</td></tr><tr><td align="center">c^</td><td align="center">删除到行首，并进入编辑模式</td></tr><tr><td align="center">c$</td><td align="center">删除到行尾，并进入编辑模式</td></tr><tr><td align="center">ct)</td><td align="center">删除到)，并进入编辑模式</td></tr><tr><td align="center">ct”</td><td align="center">删除到”，并进入编辑模式</td></tr><tr><td align="center">c[n]G</td><td align="center">删除到第n行，并进入编辑模式</td></tr><tr><td align="center">cG</td><td align="center">删除到文件末尾，并进入编辑模式</td></tr></tbody></table><p><strong>查找：</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">&#x2F;pattern</td><td align="center">从光标所在位置向后查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">?pattern</td><td align="center">从光标所在位置向前查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">n</td><td align="center">移动到下一个匹配项</td></tr><tr><td align="center">N</td><td align="center">移动到上一个匹配项</td></tr></tbody></table><p><strong>替换文本：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> :s/pattern/substitute/选项</span><br><span class="line"> 将匹配pattern的内容替换为substitute</span><br><span class="line">1) :s/pattern/substitute</span><br><span class="line">   只会替换光标所在行的第一个匹配项</span><br><span class="line">2) :s/pattern/substitute/g</span><br><span class="line"> 替换光标所在行的所有匹配项 (g for globally)</span><br><span class="line">3) :[m],[n]s/pattern/substitute/g</span><br><span class="line"> 替换[m,n]行的所有匹配项</span><br><span class="line">4) :%s/pattern/substitute/g</span><br><span class="line"> 替换全文的所有匹配项</span><br></pre></td></tr></table></figure><h2 id="1-2视图模式"><a href="#1-2视图模式" class="headerlink" title="1.2视图模式"></a>1.2视图模式</h2><p>视图模式是用来选择内容的。选择内容之后，我们就可以对其进行复制或删除了。进入视图模式有两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v: 行选模式</span><br><span class="line">[ctrl]+v: 竖选模式</span><br></pre></td></tr></table></figure><p>常见用法: 批量注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) [ctrl]+v 进入竖选模式</span><br><span class="line">2) 选择范围</span><br><span class="line">3) 输入I</span><br><span class="line">4) 输入//</span><br><span class="line">5) 输入[ESC]</span><br></pre></td></tr></table></figure><h1 id="2-对文件的操作"><a href="#2-对文件的操作" class="headerlink" title="2.对文件的操作"></a>2.对文件的操作</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">将buffer里面的内容写入文件，即保存</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存退出</td></tr><tr><td align="center">:wq</td><td align="center">保存退出</td></tr></tbody></table><p>注意：[ctrl] + s 不表示保存，而是进入僵死状态；[ctrl] + q 可以退出僵死状态。</p><h1 id="3-多窗口"><a href="#3-多窗口" class="headerlink" title="3.多窗口"></a>3.多窗口</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:split (:sp)</td><td align="center">水平分割</td></tr><tr><td align="center">:new</td><td align="center">水平分割</td></tr><tr><td align="center">:vsplit (:vsp)</td><td align="center">垂直分割</td></tr><tr><td align="center">:vnew</td><td align="center">垂直分割</td></tr><tr><td align="center">[ctrl]+ww</td><td align="center">切换窗口</td></tr><tr><td align="center">:wall</td><td align="center">保存所有修改过的窗口</td></tr><tr><td align="center">:qall</td><td align="center">退出所有窗口</td></tr><tr><td align="center">:only</td><td align="center">保留当前窗口，关闭所有其它窗口</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/07/28/linux-ming-ling/"/>
      <url>/2023/07/28/linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p><strong>查看帮助手册</strong></p><p>使用 man(manual) 命令可以查看 Linux 内置的帮助手册。该手册分为多卷：第一卷是用来查看 shell 命令的；第二卷是用来查看系统调用相关信息的；第三卷是用来查看库函数信息的…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1   可执行程序或 shell 命令</span><br><span class="line">2   系统调用(内核提供的函数)</span><br><span class="line">3   库调用(程序库中的函数)</span><br><span class="line">4   特殊文件(通常位于 /dev)</span><br><span class="line">5   文件格式和规范，如 /etc/passwd</span><br><span class="line">6   游戏</span><br><span class="line">7   杂项(包括宏包和规范，如 man(7)，groff(7))</span><br><span class="line">8   系统管理命令(通常只针对 root 用户)</span><br><span class="line">9   内核例程 [非标准</span><br></pre></td></tr></table></figure><p>man命令的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ man [手册编号] cmd</span><br><span class="line">$ man man</span><br><span class="line">$ man 3 mkdir</span><br></pre></td></tr></table></figure><p>进入帮助界面后，我们可以按下面按键浏览帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d(down): 往下翻半页</span><br><span class="line">u(up): 往上翻半页</span><br><span class="line">f(forward): 往下翻一整页</span><br><span class="line">b(backward):往上翻一整页</span><br><span class="line">q(quit): 退出</span><br></pre></td></tr></table></figure><p><strong>关机命令</strong></p><p>关闭主机之前，请务必先关闭虚拟机！否则，可能会损坏虚拟机文件，导致不能启动虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ man shutdown</span><br><span class="line"> shutdown - 挂起，关机或重启计算机</span><br><span class="line">常用选项：</span><br><span class="line"> -H, --halt: 挂起</span><br><span class="line"> -P, --poweroff: 关机(默认)</span><br><span class="line"> -r, --reboot: 重启</span><br><span class="line"> -c(cancel): 取消</span><br><span class="line"> </span><br><span class="line"> $ sudo shutdown</span><br><span class="line"> 广播关机消息给所有用户，并于一分钟后关机。</span><br><span class="line">$ sudo shutdown now</span><br><span class="line"> 立刻关机</span><br></pre></td></tr></table></figure><h2 id="用户子系统"><a href="#用户子系统" class="headerlink" title="用户子系统"></a>用户子系统</h2><p>Linux 用户可以分为：超级用户(root)和普通用户。超级用户又被称为：根用户和特权用户，它拥有至高无上的权利。普通用户又被划分为管理用户和其它用户。管理用户即我们俗称的 sudoers，他们可以临时提升权限(使用sudo命令)，安装Ubuntu过程中创建的用户默认就是 sudoers。</p><p><strong>查看所有用户</strong></p><p>Linux系统下的所有用户，在 passwd 配置文件中都有一条相关记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">he:x:1000:1000:he,,,:/home/he:/bin/bash</span><br><span class="line"></span><br><span class="line">//每一行对应一条记录，每条记录有多个字段，字段之间以 : 分割。我们可以在5号手</span><br><span class="line">册中查看 passwd 文件的格式和规范：</span><br><span class="line">$ man 5 passwd</span><br><span class="line">/etc/passwd 为每个用户账户包含一行，包含使用冒号 (“:”) 分隔的七个字段，分别是：</span><br><span class="line"> ·   登录名</span><br><span class="line"> ·   可选的加密后的密码</span><br><span class="line"> ·   数字用户 ID</span><br><span class="line"> ·   数字组 ID</span><br><span class="line"> ·   用户名和注释字段</span><br><span class="line"> ·   用户主目录</span><br><span class="line"> ·   可选的用户命令解释器</span><br></pre></td></tr></table></figure><p><strong>添加用户</strong></p><p>使用useradd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    useradd [选项] username</span><br><span class="line">    常用的选项：</span><br><span class="line">    -m, --create-home   如果不存在则创建用户的主目录</span><br><span class="line">    -s, --shell         用户的登录shell名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd test1 </span><br><span class="line"> 这样的创建该用户不会创建主目录，默认的shell为sh</span><br><span class="line">sudo useradd -m -s /bin/bash test2</span><br><span class="line"> 这样的创建该用户会创建主目录，并且指定了使用/bin/bash shell</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><p>使用userdel命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">userdel [选项] username</span><br><span class="line">常用选项：</span><br><span class="line">    -r.--remove      用户主目录中的文件将随主目录和用户邮箱一起删除</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel test1</span><br><span class="line">不会删除用户的家目录和用户的邮箱</span><br><span class="line">sudo userdel -r </span><br><span class="line">会把用户的家目录和用户的邮箱一起删除</span><br></pre></td></tr></table></figure><p><strong>设置密码</strong></p><p>使用passwd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">passwd [选项] [username]  </span><br><span class="line">可以更改用户密码，普通用户只能修改自己的密码，超级用户则可以修改任意用户的密码</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd test1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>切换用户</strong></p><p>使用su(switch user)命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sude su  切换到su用户</span><br></pre></td></tr></table></figure><p><strong>退出切换</strong></p><p>使用exit命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit    退出用户切换</span><br></pre></td></tr></table></figure><p>ps: </p><p>使用su命令依次切换到多个用户的时候，这些用户时使用栈结构来管理的。执行su命令相当于将用户压入栈顶，执行exit命令相当于将用户弹出栈顶。</p><p>当用户在上述的栈结构中存在的时候，该用户是不能被删除的。</p><h2 id="文件子系统"><a href="#文件子系统" class="headerlink" title="文件子系统"></a>文件子系统</h2><h3 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h3><p>和 Windows 不一样，Linux是以树的结构来管理文件系统的。我们将树的根结点称为根目录，用 &#x2F; 表示。</p><p><strong>常见目录</strong></p><p>在Linux中，我们是以分门别类的方式来管理文件的，也就是说，我们会将功能相似的文件放到同一个目录下进行管理。这和Windows按工程组织文件的方式不太一样。</p><p>常见目录的功能如下表所示：</p><table><thead><tr><th align="center"><strong>目录名</strong></th><th align="center"><strong>功能</strong></th></tr></thead><tbody><tr><td align="center">&#x2F;bin(binary)</td><td align="center">存放可执行程序或脚本文件</td></tr><tr><td align="center">&#x2F;sys(system)</td><td align="center">存放和系统相关的文件</td></tr><tr><td align="center">&#x2F;dev(device)</td><td align="center">存放设备文件</td></tr><tr><td align="center">&#x2F;etc</td><td align="center">一般用来存放配置文件和启动脚本</td></tr><tr><td align="center">&#x2F;lib(library)</td><td align="center">存放系统库文件</td></tr><tr><td align="center">&#x2F;var(variable)</td><td align="center">存放变化很快的文件，比如日志文件</td></tr><tr><td align="center">&#x2F;proc(process)</td><td align="center">存放进程相关的数据</td></tr><tr><td align="center">&#x2F;root</td><td align="center">root用户的家目录</td></tr><tr><td align="center">&#x2F;home&#x2F;{username}</td><td align="center">普通用户的家目录</td></tr></tbody></table><p><strong>查看当前工作目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><strong>改变当前目录</strong></p><p>使用cd(change directory)命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cd [选项] [directory]</span><br></pre></td></tr></table></figure><p>常用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd # 切换到用户家目录</span><br><span class="line">$ cd /usr/lib # 切换到/usr/lib目录</span><br><span class="line">$ cd / # 切换到 / 目录</span><br><span class="line">$ cd ~ # 切换到用户家目录</span><br><span class="line">$ cd . # 切换到当前工作目录(不切换)</span><br><span class="line">$ cd .. # 切换到父目录</span><br><span class="line">$ cd - # 切换到上一次目录</span><br></pre></td></tr></table></figure><p>注意：上一次目录保存在环境变量OLDPWD中(可以通过env命令查看)，它不是用栈结构管理的。</p><p><strong>创建目录</strong></p><p>使用mkdir命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">mkdir [选项] directory...</span><br><span class="line">常用选项：</span><br><span class="line"> -p, --parents         如果父目录不存在，则创建父目录</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir dir</span><br><span class="line">$ mkdir dir1 dir2 dir3</span><br><span class="line">$ mkdir -p a/b/c</span><br></pre></td></tr></table></figure><p>删除空目录：</p><p>使用rmdir(只能删除空目录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> rmdir [选项] dirctory...</span><br><span class="line">常用选项：</span><br><span class="line"> -p, --parents</span><br><span class="line">   递归删除空目录</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir dir</span><br><span class="line">$ rmdir dir1 dir2 dir3</span><br><span class="line">$ rmdir -p a/b/c</span><br></pre></td></tr></table></figure><p><strong>通配符</strong></p><p>可以匹配单个或多个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*: 匹配任意多个字符(包括0个)</span><br><span class="line">?: 匹配任意一个字符</span><br><span class="line">集合(类): [characters]匹配集合内任意一个字符。</span><br><span class="line">  [!characters]匹配集合外任意一个字符。</span><br><span class="line">比如：[abc], [!abc], [0-9], [a-z], [0-9A-Za-z_]等</span><br></pre></td></tr></table></figure><p>rmdir命令可以和通配符一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir dir?</span><br><span class="line">$ rmdir dir*</span><br><span class="line">$ rmdir [!abc]</span><br></pre></td></tr></table></figure><p><strong>查看目录内容</strong></p><p>ls命令可以查看目录内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">ls[选项] [FILE]...</span><br><span class="line">常用选项：</span><br><span class="line">-a,--all  显示所有的内容，包括以.开头的文件和目录</span><br><span class="line">-i，--inode  显示文件的inode编号(inode是物理文件的标识)。</span><br><span class="line">-l      以长格式的形式显示目录中的内容</span><br><span class="line">-h,  --human-readable   和-l一起使用，以人类可读的方式显示文件的大小。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls # 查看当前工作目录</span><br><span class="line">$ ls dir # 查看dir</span><br><span class="line">$ ls dir1 dir2 dir3 # 查看dir1,dir2,dir3</span><br><span class="line">$ ls -a dir # 查看dir中的所有内容，包括以.开头的文件和目录</span><br><span class="line">$ ls -ilh dir # 显示inode编号，显示详细信息，并以人类可读的方式显示文</span><br><span class="line">件的大小</span><br></pre></td></tr></table></figure><p>目录的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 8560</span><br><span class="line">-rw-rw-r--  1 he he 4349666 3月   7 11:12 a.txt</span><br><span class="line">drwxrwxr-x  2 he he    4096 3月   2 21:18 c</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>第一列的第一个字母表示文件的类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-: 普通文件</span><br><span class="line">d(directory): 目录</span><br><span class="line">c(character): 字符设备文件(鼠标，键盘，显示器...)</span><br><span class="line">b(block): 块设备文件(磁盘)</span><br><span class="line">l(symbolic link): 符号链接</span><br><span class="line">s(socket): 本地套接字</span><br><span class="line">p(named pipe): 有名管道</span><br></pre></td></tr></table></figure><ul><li><p>第1列后面九个字符(分为3组)表示权限。依次代表拥有者、拥有组和其他用户的读、写、执行权限。可读则显示r，可写则显示w，可执行则显示x， 没有相关权限则显示-。</p></li><li><p>第2列表示硬链接数。</p></li><li><p>第3列表示拥有者。</p></li><li><p>第4列表示拥有组。</p></li><li><p>第5列表示文件所占空间的大小。</p></li><li><p>第6列表示最近修改时间。</p></li><li><p>第7列为文件名。</p></li></ul><p><strong>复制文件和目录</strong></p><p>cp命令可以用来复制文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cp [选项] SOURCE DEST</span><br><span class="line">cp [选项] SOURCE ...DEST</span><br><span class="line">常用选项：</span><br><span class="line">-n, --no-clobber   如果文件已存在，则不覆盖（默认会覆盖已有文件）。</span><br><span class="line">-i, --interactive  如果文件存在，则给用户提示信息（由用户决定是否覆盖）。</span><br><span class="line">-R, -r, --recursive  递归复制（用于copy目录）。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cp text1 text2 # 将text1复制到text2中；如果text2存在，</span><br><span class="line">则覆盖。</span><br><span class="line">$ cp text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；</span><br><span class="line">如果文件已存在，则覆盖。</span><br><span class="line">$ cp -n text1 text2 # 将text1复制到text2中；如果text2存在，</span><br><span class="line">不覆盖。</span><br><span class="line">$ cp -i text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；</span><br><span class="line">如果文件已存在，则提示用户是否覆盖。</span><br><span class="line">$ cp -r dir1 dir2 # 递归地将目录dir1复制到目录dir2</span><br></pre></td></tr></table></figure><p><strong>移动文件和目录</strong></p><p>mv命令可以用来移动文件和目录，也可以用mv命令对文件和目录重命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">mv [选项] SOURCE DEST</span><br><span class="line">mv [选项] SOUCE... DEST</span><br><span class="line">常用选项：</span><br><span class="line">  -n, --no-clobber  如果文件已存在，则不覆盖（默认会覆盖已有文件）。</span><br><span class="line">  -i ,--interactive  如果文件已存在，则会给用户提示信息（由用户决定）。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv text1 text2 # 将text1重命名为text2；如果text2存在，</span><br><span class="line">则覆盖。</span><br><span class="line">$ mv dir1 dir2 # 将dir1重命名为dir2</span><br><span class="line">$ mv -n text1 text2 # 将text1重命名为text2；如果text2存在，</span><br><span class="line">不覆盖。</span><br><span class="line">$ mv text1 text2 text3 dir # 将text1,text2,text3移动到目录dir中；</span><br><span class="line">如果文件已存在，则覆盖。</span><br><span class="line">$ mv -i text1 text2 text3 dir # 将text1,text2,text3移动到目录dir中；</span><br><span class="line">如果文件已存在，则提示用户是否覆盖。</span><br></pre></td></tr></table></figure><p><strong>删除文件和目录</strong></p><p>rm命令可以删除文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">rm [选项] FILE...</span><br><span class="line">常用选项：</span><br><span class="line">-f,--force   忽略不存在的文件，永不提示。</span><br><span class="line">-i  在每次删除前，都提示用户是否删除</span><br><span class="line">-r, -R ,--recursive   递归删除</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm text1 # 删除文件text1</span><br><span class="line">$ rm text1 text2 text3 # 删除文件text1, text2, text3</span><br><span class="line">$ rm -i *.txt # 删除当前目录下所有以.txt结尾的文件，并提示用户是</span><br><span class="line">否删除</span><br><span class="line">$ rm -rf dir # 递归删除目录dir, 不给出任何提示</span><br></pre></td></tr></table></figure><p>注意：使用rm命令删除文件和目录后，就很难恢复了(Linux系统没有所谓的回收**站)。所以除非必要，不要以 root 身份或者使用 sudo 权限来执行 rm 命令!</p><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><p><strong>创建文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Hello Linus Torvalds&quot; &gt; text  # 创建文件text, 并且文件中包含内容&quot;Hello Linus Torvalds&quot;</span><br><span class="line">$ touch text1 text2 text3          # 创建空文件text1, text2, text3(要求text1,text2,text3不存在)</span><br><span class="line">$ vim hello.c         # 编辑hello.c, 按:wq退出。</span><br></pre></td></tr></table></figure><p><strong>查找文件</strong></p><ol><li><p>使用which命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">which [-a] cmd</span><br><span class="line">选项：</span><br><span class="line">-a      显示所有匹配路径</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ which bash # 查看bash的路径</span><br><span class="line">$ which ls tree # 查看命令ls和tree的路径</span><br><span class="line">$ which -a vim # 查看vim的所有路径 (我们可能装了多个版本的vim)</span><br></pre></td></tr></table></figure><p>which是根据PATH环境变量中的路径依次去查找的，然后显示第一个匹配项，或者显示所有匹配项。</p><p>可以使用env命令查看环境。由：分隔开。</p></li><li><p>find命令可以在一个目录中递归的查找符合条件的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">find [start-point...] 查找条件   # 省略start-point，默认起始点为当前工作目录</span><br></pre></td></tr></table></figure><p>常用选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-name pattern 查找文件名符合pattern的文件</span><br><span class="line">-type c      查找类型为c的文件：</span><br><span class="line">b(block): 块设备文件</span><br><span class="line"> c(character): 字符设备文件</span><br><span class="line"> d(directory): 目录</span><br><span class="line"> p(named pipe): 有名管道</span><br><span class="line"> f(file): 普通文件</span><br><span class="line"> l(symbolic link): 符号链接</span><br><span class="line">s(socket): 套接字</span><br><span class="line">-size n[cwbkMG]</span><br><span class="line">b: for 512-byte blocks (this is the default if no suffix isused)</span><br><span class="line">     c: for bytes</span><br><span class="line">           w: for two-byte words</span><br><span class="line">           k: for Kibibytes (KiB, units of 1024 bytes)</span><br><span class="line"> M: for Mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes)</span><br><span class="line">           G: for Gibibytes (GiB, units of 1024 * 1024 * 1024 =1073741824 bytes)</span><br><span class="line">           可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。</span><br><span class="line">    -empty   查找空的文件或空的文件夹</span><br><span class="line">    -user username ,-uid uid    根据用户名和用户id查找</span><br><span class="line">    -group groupname ,-gid gid  根据组名和组id查找</span><br><span class="line">    -perm mode                  根据权限查找</span><br><span class="line">根据时间查找：</span><br><span class="line">-amin n, -atime n, -cmin n, -mmin n, -mtime n</span><br><span class="line">a(access):文件访问的时间</span><br><span class="line">c(change):文件属性发生改变的时间</span><br><span class="line">m(modify):文件内容发生改变的时间</span><br><span class="line">min:以分钟为单位</span><br><span class="line">time:以天为单位</span><br><span class="line">可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。</span><br><span class="line">组合查找：</span><br><span class="line">-a(and), -o(or), !(not):分别表示与或非</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ find /usr/include -name &quot;stdio.h&quot; # 在/usr/include目录下查找stdio.h文件</span><br><span class="line">$ find . -name &quot;*.c&quot; # 在当前工作目录下查找所有以.c结尾的文件</span><br><span class="line">$ find /dev -type b # 在/dev目录下查找所有的块设备文件</span><br><span class="line">$ find . -size 5M # 在当前工作目录下查找所有大小为5M的文件</span><br><span class="line">$ find . -size +5M   # 在当前工作目录下查找所有大于5M的文件</span><br><span class="line">$ find dir1 dir2 dir3 -empty # 在dir1,dir2,dir3目录下查找所有空的文件和空的文件夹</span><br><span class="line">$ find . -user he     # 在当前工作目录下查找he用户拥有的文件</span><br><span class="line">$ find . -gid 0 # 在当前工作目录下查找root组(gid=0)拥有的文件</span><br><span class="line">$ find . -perm 664 # 在当前工作目录下查找权限为664(rwrw-r--)的文件</span><br><span class="line">$ find . -mtime 1 # 在当前工作目录下查找在[1, 2)天前内容发生修改的文件 (find会省略小数部分)</span><br><span class="line">$ find . -mtime +2    # 在当前工作目录下查找在[3, )天前内容发生修改的文件</span><br><span class="line">$ find /dev -type c -a -name &quot;tty*&quot;    # 在/dev目录下查找以tty开头的字符设备文件</span><br><span class="line">$ find /dev -type b -o -name &quot;tty*&quot;    # 在/dev目录下查找块设备文件或者是以tty开头的文件</span><br><span class="line">$ find /dev -type c -a ! -name &quot;tty*&quot; # 在/dev目录下查找不以tty开头的字符设备文件</span><br></pre></td></tr></table></figure><p><strong>查看文件内容</strong></p></li><li><p>使用cat命令查看文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cat [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-n ,--number</span><br><span class="line">  对每一行进行编导</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd</span><br><span class="line">$ cat -n /etc/passwd</span><br><span class="line">$ sudo cat /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure></li><li><p>使用head命令查看文件的前几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">head [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-n, --lines=[-]NUM</span><br><span class="line">显示前NUM行；若在NUM前面添加&#x27;-&#x27;号，则显示除了后NUM行的所有行</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ head text1 # 显示text1的前10行</span><br><span class="line">$ head text1 text2 text3 # 显示text1,text2,text3的前10行</span><br><span class="line">$ head -n 5 text1 # 显示text1的前5行</span><br><span class="line">$ head -n -5 text1 # 显示除了最后5行的所有行</span><br></pre></td></tr></table></figure></li><li><p>使用tail命令查看文件的后几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> tail [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line"> -n, --lines=[+]NUM</span><br><span class="line"> 显示后NUM行；若在NUM前面添加&#x27;+&#x27;号，则从第NUM开始显示</span><br><span class="line"> -F</span><br><span class="line"> 显示后面追加的数据。一般用于查看日志文件。</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail text1 # 显示text1的后10行</span><br><span class="line">$ tail text1 text2 text3 # 显示text1,text2,text3的后10行</span><br><span class="line">$ tail -n 5 text1 # 显示text1的后5行</span><br><span class="line">$ tail -n +5 text1 # 从第5行开始显示</span><br><span class="line">$ tail -F server.log # 显示后10行，并且会显示后面追加的数据</span><br></pre></td></tr></table></figure></li><li><p>使用less(more)单页浏览文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> more [选项] file...</span><br></pre></td></tr></table></figure><p>less是more的高级版本，若系统中没有less命令，才考虑使用more。</p><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ less text1     # 浏览text1</span><br><span class="line">$ less text1 text2    # 浏览text1, text2</span><br></pre></td></tr></table></figure><p>进入浏览页面后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(forward) 往后翻一页</span><br><span class="line">b(backward) 往前翻一页</span><br><span class="line">:n(next) 查看下一个文件</span><br><span class="line">:p(previous) 查看上一个文件</span><br><span class="line">q(quit) 退出浏览界面</span><br></pre></td></tr></table></figure></li></ol><p><strong>重定向</strong></p><p>cat,head,tail等命令经常和重定向一起使用，比如：tail -n 20 text1 &gt; a.txt。</p><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ who &gt; users                            #清空再写入</span><br><span class="line">$ echo &quot;liu yi fei&quot; &gt;&gt; users #追加</span><br><span class="line">$ wc -l &lt; users </span><br><span class="line">$ cat users file1 &gt; text # file1不存在</span><br><span class="line">$ cat users file1 2&gt; text # file1不存在</span><br><span class="line">$ cat users file1 &gt;&amp; text # file1不存在#stdin和stdout  （&gt;&amp;）</span><br></pre></td></tr></table></figure><p>输入重定向用得比较少，输出重定向用得比较多</p><p><strong>搜索文件内容</strong></p><p>grep(globally search for a regular expression)命令可以用于搜索文件内容，它的功能非常强大！grep 命令会按正则表达式去搜索文件，如果文件中某一行匹配指定的正则表达式，grep命令则会显示这一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">grep [选项] pattern [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-E, --extended-regexp   使用扩展的正则表达式</span><br><span class="line">-i, --ignore-case       忽略大小写</span><br><span class="line">-v,--invert-match       显示不匹配的正则表达式的行</span><br><span class="line">-n, --line-number       显示行号</span><br><span class="line">-c, --count             不显示匹配的行，显示匹配行的个数</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -nE &quot;firmament&quot; The_Holy_Bible.txt # 显示The_Holy_Bible.txt中包含&quot;firmament&quot;的所有行，并显示行号</span><br><span class="line">$ grep -cvE &quot;firmament&quot; The_Holy_Bible.txt # 统计The_Holy_Bible.txt中不包含&quot;firmament&quot;的行数</span><br></pre></td></tr></table></figure><p><strong>正则表达式</strong></p><p>正则表达式语法有点复杂，而且不同的工具使用的语法还不尽相同。下面我们介绍一些常用的正则表达式语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 基本单位</span><br><span class="line"> 基本单位主要包含：字符、转义字符、.(匹配任意一个字符)、集合(比如，[abc],[^abc])、(expr)</span><br><span class="line">2. 基本操作</span><br><span class="line"> 操作的对象是基本单位，主要包含两个基本操作：连接和重复</span><br><span class="line"> a. 连接：&quot;ab&quot;, &quot;[abc]x&quot;, &quot;.txt&quot;, &quot;\.txt&quot;</span><br><span class="line"> b. 重复</span><br><span class="line"> +: 重复至少一次(&gt;=1), 比如：&quot;abc+&quot;, &quot;[abc]+&quot;</span><br><span class="line"> ?: 重复零次或一次(0|1), 比如：&quot;abc?&quot;, &quot;[abc]?&quot;</span><br><span class="line"> *: 重复任意次数(&gt;=0), 比如：&quot;abc*&quot;, &quot;[abc]*&quot;, &quot;.*&quot;</span><br><span class="line"> &#123;m&#125;: 重复m次</span><br><span class="line"> &#123;m,n&#125;: 重复m到n次([m,n])</span><br><span class="line"> &#123;n, &#125;: 至少重复n次([&gt;=n])</span><br><span class="line">3. 指定基本单位出现的位置</span><br><span class="line"> ^: 行首，比如：&quot;^abc&quot;</span><br><span class="line"> $: 行尾，比如：&quot;xyz$&quot;</span><br><span class="line"> \&lt;: 词首</span><br><span class="line"> \&gt;: 词尾</span><br></pre></td></tr></table></figure><p><strong>命令的组合</strong></p><p>grep 命令之所以强大，主要在于它可以和其它命令组合使用。命令的组合主要有以下三种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.cmd1 ; cmd2</span><br><span class="line">先执行cmd1，再执行cmd2.如：mkdir dir；cd dir</span><br><span class="line">2.cmd1 | cmd2（管道）</span><br><span class="line">将上一个命令的输出作为下一个命令的输入。如：history|tail -n 20</span><br><span class="line">3.cmd1 | xargs cmd2</span><br><span class="line">xargs(extended arguments) 可以将标准输入里面的每一行转换成命令的参数</span><br><span class="line"> xargs往往和管道一起使用，如：cmd1 | xargs cmd2，它把cmd1输出的每一行作为cmd2的参数</span><br><span class="line"> find . -name &quot;*.c&quot; | xargs grep -nE &quot;\&lt;main\(&quot;       #在当前目录下找出所有.c文件的main函数</span><br></pre></td></tr></table></figure><p><strong>改变文件权限</strong></p><p>使用chmod命令可以改变文件和目录的权限。</p><p>目录：本质就是一个文件。 这个文件的内容是一个一个目录项(directory entry)，在逻辑上，目录项之间是用链表的方式链接起来的。</p><p>权限对于目录文件和普通文件的含义是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">普通文件</span><br><span class="line"> r: 可读</span><br><span class="line"> w: 可写</span><br><span class="line"> x: 可执行 (可执行程序和脚本文件需要x权限才能直接运行)</span><br><span class="line">目录</span><br><span class="line"> r: 可读 (ls)</span><br><span class="line"> w：可写 (在目录下添加和删除文件)</span><br><span class="line"> x: 可执行 (cd，读写权限依赖于x权限，所以目录一般都设置了x权限)</span><br></pre></td></tr></table></figure><p>chmod 目录的用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 文字设定法 (较少使用)</span><br><span class="line"> chmod [ugoa][+=-][rwx] file/dir</span><br><span class="line"> u: user</span><br><span class="line"> g: group</span><br><span class="line"> o: other</span><br><span class="line"> a: all</span><br><span class="line"> +: 添加权限</span><br><span class="line"> -: 删除权限</span><br><span class="line"> =: 将权限设置为</span><br><span class="line">2. 数字设定法 (常用)</span><br><span class="line"> chmod mode file/dir</span><br><span class="line"> mode: 三位八进制数字</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod o+w text1                  #other添加可写权限</span><br><span class="line">$ chmod u=rwx,g=rx,o=r text1       #user权限为rwx,group的权限为rx,other权限为r</span><br><span class="line">$ chmod 664 text1   #rw- rw- r--</span><br></pre></td></tr></table></figure><p><strong>文件创建掩码</strong></p><p>文件和目录在创建的时候都有一个默认的权限，该权限是由文件创建掩码 umask 决定的。我们可以用 umask 命令查看当前的文件创建掩码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ umask</span><br><span class="line">  0002 # 当前的文件创建掩码为2  </span><br></pre></td></tr></table></figure><p>接下来，我们创建文件 text 和目录 dir，查看它们的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxrwxr-x  2 he he 4096 3月  12 20:55 dir/</span><br><span class="line">-rw-rw-r--  1 he he    0 3月  13 20:34 text</span><br></pre></td></tr></table></figure><p>可见当 umask &#x3D; 0002 时，目录的默认权限为 775，文件的默认权限为 664</p><p>将文件创建掩码 umask 设置为 0023</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask 0023</span><br></pre></td></tr></table></figure><p>再创建文件 text1 和目录 dir1，查看它们的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr-xr-- 2 he he 4096 3月  13 20:40 dir1</span><br><span class="line">-rw-r--r-- 1 he he    0 3月  13 20:40 text1</span><br></pre></td></tr></table></figure><p>可见当 umask &#x3D; 0023 时，目录的默认权限为 754，文件的默认权限为 644 (643-023)</p><p><strong>目录的权限初始为777，普通文件的权限初始为666，与umask相与后为默认权限。</strong></p><p><strong>链接</strong></p><p>我们可以用 ln 命令创建硬链接和符号连接(软链接)。</p><p>创建硬链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ln text1 h_link</span><br><span class="line">$ ls -li</span><br><span class="line">268648 -rw-r--r-- 2 he he    0 3月  13 20:40 h_link</span><br><span class="line">268648 -rw-r--r-- 2 he he    0 3月  13 20:40 text1</span><br></pre></td></tr></table></figure><p>可见 text1 和 h_link 是指向同一个文件的，并且硬链接数也由原来的 1 变成了 2。删除 text1 或 h_link 只会减少硬链接数，当硬链接数为 0 的时候，才会真正删除磁盘上的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm text1</span><br><span class="line">$ ls -li</span><br><span class="line">268648 -rw-r--r-- 1 he he    0 3月  13 20:40 h_link       # 硬链接数变为了 1</span><br><span class="line">$ rm h_link</span><br></pre></td></tr></table></figure><p>创建符号链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s text s_link</span><br><span class="line">$ ls -li</span><br><span class="line">268648 lrwxrwxrwx 1 he he 4 3月  13 21:24 s_link -&gt; text # s_link文件的内容为text，因此大小为4</span><br><span class="line">264859 -rw-rw-r-- 1 he he 0 3月  13 20:34 text</span><br></pre></td></tr></table></figure><p>可见 text 和 s_link 是指向不同文件的，text 的硬链接数不会发生改变。删除 text 会导致符号链接 s_link 悬空：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm text</span><br><span class="line">$ ls -li</span><br><span class="line">268648 lrwxrwxrwx 1 he he 4 3月  13 21:24 s_link -&gt; text # 颜色会发生</span><br><span class="line">改变</span><br></pre></td></tr></table></figure><p>我们可以将符号链接和 Windows 系统上的快捷方式，或者 C 语言中的指针做类比。对于大多数命令(rm除外)，如果参数是符号链接，其实操作的是符号链接指向的文件(类似指针的解引用操作)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;I love xixi\n&quot; &gt; text</span><br><span class="line">$ cat s_link</span><br><span class="line">I love xixi</span><br><span class="line">$ rm s_link # 删除符号链接</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><strong>远程复制</strong></p><p>scp 命令可以用于上传和下载文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上传：将本地的文件复制到远程</span><br><span class="line">下载：将远程的文件复制到本地</span><br></pre></td></tr></table></figure><p>scp 的用法和 cp 非常类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> scp [选项] SRC... DEST</span><br><span class="line"> 本地路径：可以用绝对路径，也可以用相对路径</span><br><span class="line"> 远程路径：用户名@IP:路径</span><br><span class="line">常用选项：</span><br><span class="line"> -r      </span><br><span class="line"> 递归复制整个目录</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp he@IP:~/text1 . # 将he用户家目录下的text1文件下载到当前工作目录</span><br><span class="line">$ scp ./file he@IP:~ # 将当前工作目录下的file文件上传到he用户的家目录下</span><br></pre></td></tr></table></figure><p><strong>打包压缩</strong></p><p>我们可以用 tar 命令打包和压缩文件。tar 是一个非常有历史的工具，这里我们只介绍它的传统(经典)用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> tar [主选项+辅选项] 包名 [文件或目录]...</span><br><span class="line"> 主选项(有且只能选择其中一个)：</span><br><span class="line"> c: 创建</span><br><span class="line"> r: 追加</span><br><span class="line"> x: 释放</span><br><span class="line"> 辅选项：</span><br><span class="line"> f: 指定包文件的名称</span><br><span class="line"> v: 显示详细信息</span><br><span class="line"> z: 使用gzip算法压缩或解压缩包文件</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf package.tar text*</span><br><span class="line">$ tar rvf package.tar The_Holy_Bible.txt</span><br><span class="line">$ tar xvf package.tar</span><br><span class="line">$ tar czvf package.tar.gz *</span><br><span class="line">$ tar xzvf package.tar.gz</span><br></pre></td></tr></table></figure><p><strong>别名</strong></p><p>有些命令比较长，自然我们就想给这些命令起一个别名，方便以后使用，alias 命令就是用来做这事情的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> alias [命令=别名]...</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ alias # 查看别名</span><br><span class="line">alias g++11=&#x27;g++ -std=c++11&#x27;</span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">...</span><br><span class="line">$ alias h=&#x27;history&#x27; # 设置别名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章数组和第七章递归</title>
      <link href="/2023/07/28/di-liu-zhang-shu-zu-di-qi-zhang-di-gui/"/>
      <url>/2023/07/28/di-liu-zhang-shu-zu-di-qi-zhang-di-gui/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们见过的变量都只能存储单个数据项，这样的变量称为标量(scalar)。C 语言也支持聚合变量，这类变量可以存储多个数据项。C 语言提供两种类型的聚合变量：数组和结构体。</p><span id="more"></span><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1.一维数组"></a>1.一维数组</h2><h3 id="内存模型："><a href="#内存模型：" class="headerlink" title="内存模型："></a>内存模型：</h3><h4 id="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"><a href="#一片连续的内存空间，并且这片空间划分成大小相等的小空间。" class="headerlink" title="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"></a>一片连续的内存空间，并且这片空间划分成大小相等的小空间。</h4><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><p>（初始化）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[10]=&#123;1,2&#125;;</span><br><span class="line">int a[]=&#123;1,2,3,4&#125;;</span><br></pre></td></tr></table></figure><p>编译器会利用初始化式的长度来确定数组的长度，数组的长度为初始值。</p><h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2.二维数组"></a>2.二维数组</h2><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><h4 id="元素是一维数组的数组。"><a href="#元素是一维数组的数组。" class="headerlink" title="元素是一维数组的数组。"></a>元素是一维数组的数组。</h4><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 1, 1, 1&#125;&#125;;</span><br><span class="line"> //如果初始化式的长度不够，那么剩余元素被初始化为 0。如，下面的初始化式只填充了数组的前 3 行，后面 2 行将被 //初始化为 0。</span><br><span class="line"> int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;&#125;;</span><br><span class="line">    //甚至，我们可以省略内存的大括号 (不推荐)。</span><br><span class="line">    int matrix[5][9] = &#123;1, 1, 1, 1, 1, 0, 1, 1, 1,</span><br><span class="line">                    0, 1, 0, 1, 0, 1, 0, 1, 0,</span><br><span class="line">                    0, 1, 0, 1, 1, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 1, 1, 1&#125;;</span><br></pre></td></tr></table></figure><p>编译器一旦发现值足以填满一行，它就开始填充下一行。</p><p><strong>ps:在初始化式中省略内层大括号是非常危险的，因为不小心多写或者少写一</strong></p><p><strong>个值都会影响后面元素的初始化。</strong></p><h2 id="3-常量数组"><a href="#3-常量数组" class="headerlink" title="3.常量数组"></a>3.常量数组</h2><h5 id="无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”："><a href="#无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”：" class="headerlink" title="无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”："></a>无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char hex_chars[] =</span><br><span class="line"> &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,</span><br><span class="line"> &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;;</span><br></pre></td></tr></table></figure><h5 id="程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"><a href="#程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。" class="headerlink" title="程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"></a>程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。</h5><h4 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h4><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714230439487.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714230439487.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714230439487"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(0));//初始化种子为随机值</span><br><span class="line">const char hex_chars[][13] = &#123; &#123;&#x27;a&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,&#x27;t&#x27;,&#x27;j&#x27;,&#x27;q&#x27;,&#x27;k&#x27;&#125;,</span><br><span class="line">  &#123;&#x27;d&#x27;, &#x27;h&#x27;, &#x27;c&#x27;, &#x27;s&#x27;&#125; &#125;;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;发几张牌：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">bool arr[4][13] = &#123; false &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; ) &#123;</span><br><span class="line">int num1,num2;</span><br><span class="line">num1 = rand() % 13;</span><br><span class="line">num2 = rand() % 4;</span><br><span class="line">if (arr[num2 ][num1 ]==false ) &#123;</span><br><span class="line">arr[num2][num1] = true;</span><br><span class="line">i++;</span><br><span class="line">printf(&quot;%c%c\n&quot;, hex_chars[0][num1], hex_chars[1][num2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1函数的定义"><a href="#1函数的定义" class="headerlink" title="1函数的定义"></a>1函数的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return-type function-name (parameters) &#123;</span><br><span class="line">declarations</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。"><a href="#返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。" class="headerlink" title="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。"></a>返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。</h5><h5 id="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。"><a href="#函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。" class="headerlink" title="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。"></a>函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。</h5><h5 id="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"><a href="#函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。" class="headerlink" title="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"></a>函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。</h5><h2 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2.函数的调用"></a>2.函数的调用</h2><h5 id="函数调用由函数名和实际参数-argument-列表组成。"><a href="#函数调用由函数名和实际参数-argument-列表组成。" class="headerlink" title="函数调用由函数名和实际参数 (argument) 列表组成。"></a>函数调用由函数名和实际参数 (argument) 列表组成。</h5><h5 id="void-函数调用必须紧跟分号，如："><a href="#void-函数调用必须紧跟分号，如：" class="headerlink" title="void 函数调用必须紧跟分号，如："></a>void 函数调用必须紧跟分号，如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_pun();</span><br></pre></td></tr></table></figure><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714231132461.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714231132461.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714231132461"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">int k = sqrt(n); int i;</span><br><span class="line">for ( i = 2; i &lt;=k; i++) &#123;</span><br><span class="line">if (n % i == 0) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (i &lt;= k)return false;</span><br><span class="line">else return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int m;</span><br><span class="line">printf(&quot;输入m:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">if (isPrime(m)) &#123;</span><br><span class="line">printf(&quot;\n%d为素数&quot;, m);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;\n%d不为素数&quot;, m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实际参数"><a href="#3-实际参数" class="headerlink" title="3.实际参数"></a>3.实际参数</h2><h5 id="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"><a href="#形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。" class="headerlink" title="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"></a>形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。</h5><h5 id="在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"><a href="#在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。" class="headerlink" title="在 C 语言中实参是值传递 (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"></a>在 C 语言中实参是<strong>值传递</strong> (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。</h5><h5 id="但是值传递也会使得某些函数变得难以编写。如："><a href="#但是值传递也会使得某些函数变得难以编写。如：" class="headerlink" title="但是值传递也会使得某些函数变得难以编写。如："></a>但是值传递也会使得某些函数变得难以编写。如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;//error</span><br></pre></td></tr></table></figure><p>PS<br>局部变量：定义在函数内部的变量只能在函数内部使用。<br>上面代码里在main函数中定义的a，b与Swap函数中a，b只是同名，只在Swap函数中交换a与b的值而不影响main函数中的a与b的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sawp(int *p1,int *p2)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">tmp=*p1;//tmp＝a</span><br><span class="line">*p1=*p2;//a＝b</span><br><span class="line">*p2=tmp;//b＝tmp</span><br><span class="line">&#125;  //true</span><br></pre></td></tr></table></figure><p>一个函数（父函数）调用另一个函数（子函数），想通过子函数修改父函数的数据，必须传指针，子函数内部解引用。也就是子函数的改变要想影响父函数的数据必须传指针和解引用。</p><h2 id="4-数组作为参数"><a href="#4-数组作为参数" class="headerlink" title="4.数组作为参数"></a>4.数组作为参数</h2><h5 id="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："><a href="#我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：" class="headerlink" title="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："></a>我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f(int a[]) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组作为参数传递时，会退化成指向数组第一个元素的指针"><a href="#数组作为参数传递时，会退化成指向数组第一个元素的指针" class="headerlink" title="数组作为参数传递时，会退化成指向数组第一个元素的指针"></a><strong>数组作为参数传递时，会退化成指向数组第一个元素的指针</strong></h4><h5 id="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"><a href="#实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。" class="headerlink" title="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"></a>实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。</h5><h5 id="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："><a href="#如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：" class="headerlink" title="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："></a>如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define LEN 10</span><br><span class="line">int sum_array(int a[][LEN], int n) &#123;</span><br><span class="line">int i, j, sum = 0;</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">for (j = 0; j &lt; LEN; j++)</span><br><span class="line">sum += a[i][j];</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-局部变量和外部变量"><a href="#5-局部变量和外部变量" class="headerlink" title="5.局部变量和外部变量"></a>5.局部变量和外部变量</h2><h5 id="我们把在函数体内声明的变量称为该函数的局部变量。"><a href="#我们把在函数体内声明的变量称为该函数的局部变量。" class="headerlink" title="我们把在函数体内声明的变量称为该函数的局部变量。"></a>我们把在函数体内声明的变量称为该函数的<strong>局部变量</strong>。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum_digits(int n) &#123;</span><br><span class="line">int sum = 0; /*local variable*/</span><br><span class="line">while (n &gt; 0) &#123;</span><br><span class="line">sum += n % 10;</span><br><span class="line">n /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，局部变量具有下列性质：</p><ul><li><strong>自动存储期限</strong>。简单来讲，存储期限就是变量在程序运行过程中存在的时间长度。局部变量的存储单元在函数调用时”自动”分配，在函数返回时自动回收，所以称这种变量具有自动存储期限。</li><li><strong>块作用域</strong>。变量的作用域就是：在程序文本中可以引用该变量的部分。局部变量拥有块作用域 ：从变量声明的点开始一直到所在块的末尾。块：简单来说，就是用 {} 括起来的文本区域。</li></ul><h3 id="5-1静态局部变量"><a href="#5-1静态局部变量" class="headerlink" title="5.1静态局部变量"></a>5.1静态局部变量</h3><h5 id="在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："><a href="#在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：" class="headerlink" title="在局部变量声明中使用 static 关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："></a>在局部变量声明中使用 static 关键字，可以使局部变量具有<strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">static int i = 0;</span><br><span class="line">printf(&quot;%p: %d\n&quot;, &amp;i, i++);</span><br><span class="line">&#125;</span><br><span class="line">//静态局部变量始终具有块作用域，所以它对其他函数是不可见的。</span><br></pre></td></tr></table></figure><h5 id="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："><a href="#静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：" class="headerlink" title="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："></a>静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line">long long next_fib(void) &#123;</span><br><span class="line">static long long a = 0;</span><br><span class="line">static long long b = 1;</span><br><span class="line">long long tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = a + tmp;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 2</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 3</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2外部变量"><a href="#5-2外部变量" class="headerlink" title="5.2外部变量"></a>5.2外部变量</h3><p>外部变量(全局变量)就是声明在任何函数体外的变量，外部变量的性质不同于局部变量：</p><ul><li><strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li><li><strong>文件作用域</strong>。从变量声明开始，一直到文件的末尾。因此，在外部变量声明之后的函数都可以访问(并修改)它。</li></ul><p>在多个函数必须共享一个变量时，外部变量是很有用的。然而，在大多数情况下，函数之间通过形式参</p><p>数进行通信会比共享外部变量更好。<strong>使用外部变量不利于程序的排错和维护。</strong></p><h2 id="6-return语句"><a href="#6-return语句" class="headerlink" title="6.return语句"></a>6.return语句</h2><p>void 函数也可以使用 return 语句，使函数立刻返回，只是 return 后面不能接表达式。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print_positive(int n) &#123;</span><br><span class="line">if (n &lt;= 0)</span><br><span class="line">return ;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h2><p>从递归的定义去理解递归不是很好，我们可以从名字入手去理解。</p><ol><li><p>递：把大问题分解成若干个子问题，子问题的求解方式和大问题一致，只是问题规模不一致。</p></li><li><p>归：把子问题的解合并成大问题的解。</p></li></ol><ul><li><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2</span><br><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">return fib(n-2) + fib(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种求解方式的效率很低，会存在大量重复的计算。如下图所示：</p><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230716212709055.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230716212709055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230716212709055"></p></li></ul><p>so，如何避免重复计算问题呢？</p><p>答案是动态规划。顺序求解子问题，并将子问题的解保存起来，从而避免重复计算，最终求解到大问</p><p>题。</p><p>但是对于求解 Fibnacci 数列来说，我们并不需要保存前面所有项的值，我们只需要保存最近两项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">long long a = 0, b = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">// 计算fib(i)的值</span><br><span class="line">long long tmp = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p><strong>代码实现的思路主要分为三步：</strong><br>假设总共需要移动n个盘子<br>1.将A柱上的n-1个盘子借助C柱移向B柱<br>2.将A柱上仅剩的最后一个盘子移向C柱<br>3.将B柱上的n-1个盘子借助A柱移向C柱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void move(int n, char a, char b, char c) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;, a,c);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">move(n - 1, a, c,b);</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;,a,c );</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">move(n - 1, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;n:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h4><p>哪个人先出列一个人，在重新编号。变成n-1个人，直到只剩下一个人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define  _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">     //             f(N,M)=(f(N−1,M)+M)%N</span><br><span class="line"></span><br><span class="line">int joseph(int n, int m) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123; </span><br><span class="line">return (joseph(n - 1, m) + m) % n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n, m,k;</span><br><span class="line">printf(&quot;输入n：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;\n输入m：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">k=joseph(n, m);</span><br><span class="line">printf(&quot;\n活下来人的编号为：%d&quot;, k+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
