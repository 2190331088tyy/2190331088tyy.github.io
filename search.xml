<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2023/07/28/Vim/"/>
      <url>/2023/07/28/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h1><p>Vim(Vi improved) 是从 Vi 发展出来的一个文本编辑器。Vim 在程序员中使用地非常广泛，和 Emacs 并称为类 Unix 系统用户最喜欢的文本编辑器。事实上，这两大编辑神器之间的圣战一直没停歇过。</p><span id="more"></span><p><strong>Vim</strong> <strong>的设计理念是</strong> <strong>Composability</strong> (<strong>组合</strong>):</p><p>例如在 Vim 中，”d” 表示删除，”j” 移动到下一行，组合 “dj” 表示删除当前行和下一行；”^” 代表行首，故组合 “d^” 表示删除到行首；”$” 代表行尾，”d$” 表示删除到行尾。而且我们还可以指定命令重复的次数：”dd” 表示删除光标所在行，”2dd” 或”d2d” 表示连续删除两行，效果和 “dj” 一致。</p><p>Vim 是一种模式编辑器，它与我们熟悉的”所见即所得”的编辑器不太一样。Vim 在不同模式下有不同的功能，这也是 Vim 之所有这么 NB 的原因之一。Vim 有多种模式，最常用的是：普通(命令)模式、插入(编辑)模式和视图模式。这些模式之间可以相互转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 在光标前面插入</span><br><span class="line">I: 在行首插入</span><br><span class="line">a: 在光标后面插入</span><br><span class="line">A: 在行尾插入</span><br><span class="line">o: 在下面另起一行，并在行首插入</span><br><span class="line">O: 在上面另起一行，并在行首插入</span><br><span class="line">v: 进入行选模式</span><br><span class="line">[ctrl]+v: 进入竖选模式</span><br></pre></td></tr></table></figure><h2 id="1-1普通模式"><a href="#1-1普通模式" class="headerlink" title="1.1普通模式"></a>1.1普通模式</h2><p>普通模式又叫命令模式，顾名思义，这种模式就是用来执行各种命令的。命令可以分为长命令和短命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">长命令：以:开头，以[Enter]结尾的命令。比如，:wq[Enter]</span><br><span class="line">短命令：如a,o,i...</span><br></pre></td></tr></table></figure><p><strong>移动光标</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">往左移动一个字符</td></tr><tr><td align="center">j</td><td align="center">往下移动一个字符</td></tr><tr><td align="center">k</td><td align="center">往上移动一个字符</td></tr><tr><td align="center">l</td><td align="center">往右移动一个字符</td></tr><tr><td align="center">[n]-</td><td align="center">往上移动n行</td></tr><tr><td align="center">[n]+</td><td align="center">往下移动n行</td></tr><tr><td align="center">:[n] 或 [n]G</td><td align="center">移动到第n行</td></tr><tr><td align="center">gg</td><td align="center">移动到文件的第一行</td></tr><tr><td align="center">G</td><td align="center">移动到文件的最后一行</td></tr><tr><td align="center">^</td><td align="center">移动到这一行的第一个非空白字符处</td></tr><tr><td align="center">$</td><td align="center">移动到行尾</td></tr><tr><td align="center">w</td><td align="center">下一个单词的词首</td></tr><tr><td align="center">b</td><td align="center">上一个单词的词首</td></tr><tr><td align="center">t)</td><td align="center">向后查找，将光标移动到)的前一个字符</td></tr><tr><td align="center">T”</td><td align="center">向前查找，将光标移动到”的后一个字符</td></tr><tr><td align="center">f)</td><td align="center">向后查找，将光标移动到)</td></tr><tr><td align="center">F”</td><td align="center">向前查找，将光标移动到”</td></tr></tbody></table><p><strong>删除文本</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除一个字符</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词</td></tr><tr><td align="center">[n]dw 或 d[n]w</td><td align="center">删除n个单词</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">[n]dd 或 d[n]d</td><td align="center">删除n行</td></tr><tr><td align="center">:[m],[n]d</td><td align="center">删除[m,n]行</td></tr><tr><td align="center">d^</td><td align="center">删除到行首</td></tr><tr><td align="center">d$</td><td align="center">删除到行尾</td></tr><tr><td align="center">dt)</td><td align="center">删除到)</td></tr><tr><td align="center">dt”</td><td align="center">删除到”</td></tr></tbody></table><p><strong>粘贴，撤销和恢复</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">p 或 P(paste)</td><td align="center">粘贴</td></tr><tr><td align="center">u(undo)</td><td align="center">撤销</td></tr><tr><td align="center">[ctrl] + r(recovery)</td><td align="center">恢复</td></tr></tbody></table><p><strong>复制文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">[n]yy 或 y[n]y</td><td align="center">复制n行</td></tr><tr><td align="center">:[m],[n]y</td><td align="center">复制[m,n]行</td></tr><tr><td align="center">yw</td><td align="center">复制一个单词</td></tr><tr><td align="center">[n]yw 或 y[n]w</td><td align="center">复制n个单词</td></tr><tr><td align="center">yt)</td><td align="center">复制到)</td></tr><tr><td align="center">yt”</td><td align="center">复制到”</td></tr></tbody></table><p><strong>修改文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">cc 或 S</td><td align="center">删除当前行，并进入编辑模式</td></tr><tr><td align="center">[n]cc 或 [n]S</td><td align="center">删除n行，并进入编辑模式</td></tr><tr><td align="center">cw</td><td align="center">删除一个单词，并进入编辑模式</td></tr><tr><td align="center">[n]cw 或 c[n]w</td><td align="center">删除n个单词，并进入编辑模式</td></tr><tr><td align="center">c^</td><td align="center">删除到行首，并进入编辑模式</td></tr><tr><td align="center">c$</td><td align="center">删除到行尾，并进入编辑模式</td></tr><tr><td align="center">ct)</td><td align="center">删除到)，并进入编辑模式</td></tr><tr><td align="center">ct”</td><td align="center">删除到”，并进入编辑模式</td></tr><tr><td align="center">c[n]G</td><td align="center">删除到第n行，并进入编辑模式</td></tr><tr><td align="center">cG</td><td align="center">删除到文件末尾，并进入编辑模式</td></tr></tbody></table><p><strong>查找：</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">&#x2F;pattern</td><td align="center">从光标所在位置向后查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">?pattern</td><td align="center">从光标所在位置向前查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">n</td><td align="center">移动到下一个匹配项</td></tr><tr><td align="center">N</td><td align="center">移动到上一个匹配项</td></tr></tbody></table><p><strong>替换文本：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> :s/pattern/substitute/选项</span><br><span class="line"> 将匹配pattern的内容替换为substitute</span><br><span class="line">1) :s/pattern/substitute</span><br><span class="line">   只会替换光标所在行的第一个匹配项</span><br><span class="line">2) :s/pattern/substitute/g</span><br><span class="line"> 替换光标所在行的所有匹配项 (g for globally)</span><br><span class="line">3) :[m],[n]s/pattern/substitute/g</span><br><span class="line"> 替换[m,n]行的所有匹配项</span><br><span class="line">4) :%s/pattern/substitute/g</span><br><span class="line"> 替换全文的所有匹配项</span><br></pre></td></tr></table></figure><h2 id="1-2视图模式"><a href="#1-2视图模式" class="headerlink" title="1.2视图模式"></a>1.2视图模式</h2><p>视图模式是用来选择内容的。选择内容之后，我们就可以对其进行复制或删除了。进入视图模式有两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v: 行选模式</span><br><span class="line">[ctrl]+v: 竖选模式</span><br></pre></td></tr></table></figure><p>常见用法: 批量注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) [ctrl]+v 进入竖选模式</span><br><span class="line">2) 选择范围</span><br><span class="line">3) 输入I</span><br><span class="line">4) 输入//</span><br><span class="line">5) 输入[ESC]</span><br></pre></td></tr></table></figure><h1 id="2-对文件的操作"><a href="#2-对文件的操作" class="headerlink" title="2.对文件的操作"></a>2.对文件的操作</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">将buffer里面的内容写入文件，即保存</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存退出</td></tr><tr><td align="center">:wq</td><td align="center">保存退出</td></tr></tbody></table><p>注意：[ctrl] + s 不表示保存，而是进入僵死状态；[ctrl] + q 可以退出僵死状态。</p><h1 id="3-多窗口"><a href="#3-多窗口" class="headerlink" title="3.多窗口"></a>3.多窗口</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:split (:sp)</td><td align="center">水平分割</td></tr><tr><td align="center">:new</td><td align="center">水平分割</td></tr><tr><td align="center">:vsplit (:vsp)</td><td align="center">垂直分割</td></tr><tr><td align="center">:vnew</td><td align="center">垂直分割</td></tr><tr><td align="center">[ctrl]+ww</td><td align="center">切换窗口</td></tr><tr><td align="center">:wall</td><td align="center">保存所有修改过的窗口</td></tr><tr><td align="center">:qall</td><td align="center">退出所有窗口</td></tr><tr><td align="center">:only</td><td align="center">保留当前窗口，关闭所有其它窗口</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第六章数组和第七章递归</title>
      <link href="/2023/07/28/%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B0%E7%BB%84+%E7%AC%AC%E4%B8%83%E7%AB%A0%E9%80%92%E5%BD%92/"/>
      <url>/2023/07/28/%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B0%E7%BB%84+%E7%AC%AC%E4%B8%83%E7%AB%A0%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们见过的变量都只能存储单个数据项，这样的变量称为标量(scalar)。C 语言也支持聚合变量，这类变量可以存储多个数据项。C 语言提供两种类型的聚合变量：数组和结构体。</p><span id="more"></span><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1.一维数组"></a>1.一维数组</h2><h3 id="内存模型："><a href="#内存模型：" class="headerlink" title="内存模型："></a>内存模型：</h3><h4 id="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"><a href="#一片连续的内存空间，并且这片空间划分成大小相等的小空间。" class="headerlink" title="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"></a>一片连续的内存空间，并且这片空间划分成大小相等的小空间。</h4><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><p>（初始化）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[10]=&#123;1,2&#125;;</span><br><span class="line">int a[]=&#123;1,2,3,4&#125;;</span><br></pre></td></tr></table></figure><p>编译器会利用初始化式的长度来确定数组的长度，数组的长度为初始值。</p><h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2.二维数组"></a>2.二维数组</h2><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><h4 id="元素是一维数组的数组。"><a href="#元素是一维数组的数组。" class="headerlink" title="元素是一维数组的数组。"></a>元素是一维数组的数组。</h4><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 1, 1, 1&#125;&#125;;</span><br><span class="line"> //如果初始化式的长度不够，那么剩余元素被初始化为 0。如，下面的初始化式只填充了数组的前 3 行，后面 2 行将被 //初始化为 0。</span><br><span class="line"> int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;&#125;;</span><br><span class="line">    //甚至，我们可以省略内存的大括号 (不推荐)。</span><br><span class="line">    int matrix[5][9] = &#123;1, 1, 1, 1, 1, 0, 1, 1, 1,</span><br><span class="line">                    0, 1, 0, 1, 0, 1, 0, 1, 0,</span><br><span class="line">                    0, 1, 0, 1, 1, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 1, 1, 1&#125;;</span><br></pre></td></tr></table></figure><p>编译器一旦发现值足以填满一行，它就开始填充下一行。</p><p><strong>ps:在初始化式中省略内层大括号是非常危险的，因为不小心多写或者少写一</strong></p><p><strong>个值都会影响后面元素的初始化。</strong></p><h2 id="3-常量数组"><a href="#3-常量数组" class="headerlink" title="3.常量数组"></a>3.常量数组</h2><h5 id="无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”："><a href="#无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”：" class="headerlink" title="无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”："></a>无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char hex_chars[] =</span><br><span class="line"> &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,</span><br><span class="line"> &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;;</span><br></pre></td></tr></table></figure><h5 id="程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"><a href="#程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。" class="headerlink" title="程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"></a>程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。</h5><h4 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h4><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714230439487.png" alt="image-20230714230439487"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(0));//初始化种子为随机值</span><br><span class="line">const char hex_chars[][13] = &#123; &#123;&#x27;a&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,&#x27;t&#x27;,&#x27;j&#x27;,&#x27;q&#x27;,&#x27;k&#x27;&#125;,</span><br><span class="line">  &#123;&#x27;d&#x27;, &#x27;h&#x27;, &#x27;c&#x27;, &#x27;s&#x27;&#125; &#125;;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;发几张牌：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">bool arr[4][13] = &#123; false &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; ) &#123;</span><br><span class="line">int num1,num2;</span><br><span class="line">num1 = rand() % 13;</span><br><span class="line">num2 = rand() % 4;</span><br><span class="line">if (arr[num2 ][num1 ]==false ) &#123;</span><br><span class="line">arr[num2][num1] = true;</span><br><span class="line">i++;</span><br><span class="line">printf(&quot;%c%c\n&quot;, hex_chars[0][num1], hex_chars[1][num2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1函数的定义"><a href="#1函数的定义" class="headerlink" title="1函数的定义"></a>1函数的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return-type function-name (parameters) &#123;</span><br><span class="line">declarations</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。"><a href="#返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。" class="headerlink" title="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。"></a>返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。</h5><h5 id="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。"><a href="#函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。" class="headerlink" title="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。"></a>函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。</h5><h5 id="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"><a href="#函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。" class="headerlink" title="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"></a>函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。</h5><h2 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2.函数的调用"></a>2.函数的调用</h2><h5 id="函数调用由函数名和实际参数-argument-列表组成。"><a href="#函数调用由函数名和实际参数-argument-列表组成。" class="headerlink" title="函数调用由函数名和实际参数 (argument) 列表组成。"></a>函数调用由函数名和实际参数 (argument) 列表组成。</h5><h5 id="void-函数调用必须紧跟分号，如："><a href="#void-函数调用必须紧跟分号，如：" class="headerlink" title="void 函数调用必须紧跟分号，如："></a>void 函数调用必须紧跟分号，如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_pun();</span><br></pre></td></tr></table></figure><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714231132461.png" alt="image-20230714231132461"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">int k = sqrt(n); int i;</span><br><span class="line">for ( i = 2; i &lt;=k; i++) &#123;</span><br><span class="line">if (n % i == 0) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (i &lt;= k)return false;</span><br><span class="line">else return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int m;</span><br><span class="line">printf(&quot;输入m:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">if (isPrime(m)) &#123;</span><br><span class="line">printf(&quot;\n%d为素数&quot;, m);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;\n%d不为素数&quot;, m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实际参数"><a href="#3-实际参数" class="headerlink" title="3.实际参数"></a>3.实际参数</h2><h5 id="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"><a href="#形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。" class="headerlink" title="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"></a>形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。</h5><h5 id="在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"><a href="#在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。" class="headerlink" title="在 C 语言中实参是值传递 (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"></a>在 C 语言中实参是<strong>值传递</strong> (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。</h5><h5 id="但是值传递也会使得某些函数变得难以编写。如："><a href="#但是值传递也会使得某些函数变得难以编写。如：" class="headerlink" title="但是值传递也会使得某些函数变得难以编写。如："></a>但是值传递也会使得某些函数变得难以编写。如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;//error</span><br></pre></td></tr></table></figure><p>PS<br>局部变量：定义在函数内部的变量只能在函数内部使用。<br>上面代码里在main函数中定义的a，b与Swap函数中a，b只是同名，只在Swap函数中交换a与b的值而不影响main函数中的a与b的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sawp(int *p1,int *p2)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">tmp=*p1;//tmp＝a</span><br><span class="line">*p1=*p2;//a＝b</span><br><span class="line">*p2=tmp;//b＝tmp</span><br><span class="line">&#125;  //true</span><br></pre></td></tr></table></figure><p>一个函数（父函数）调用另一个函数（子函数），想通过子函数修改父函数的数据，必须传指针，子函数内部解引用。也就是子函数的改变要想影响父函数的数据必须传指针和解引用。</p><h2 id="4-数组作为参数"><a href="#4-数组作为参数" class="headerlink" title="4.数组作为参数"></a>4.数组作为参数</h2><h5 id="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："><a href="#我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：" class="headerlink" title="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："></a>我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f(int a[]) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组作为参数传递时，会退化成指向数组第一个元素的指针"><a href="#数组作为参数传递时，会退化成指向数组第一个元素的指针" class="headerlink" title="数组作为参数传递时，会退化成指向数组第一个元素的指针"></a><strong>数组作为参数传递时，会退化成指向数组第一个元素的指针</strong></h4><h5 id="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"><a href="#实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。" class="headerlink" title="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"></a>实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。</h5><h5 id="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："><a href="#如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：" class="headerlink" title="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："></a>如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define LEN 10</span><br><span class="line">int sum_array(int a[][LEN], int n) &#123;</span><br><span class="line">int i, j, sum = 0;</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">for (j = 0; j &lt; LEN; j++)</span><br><span class="line">sum += a[i][j];</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-局部变量和外部变量"><a href="#5-局部变量和外部变量" class="headerlink" title="5.局部变量和外部变量"></a>5.局部变量和外部变量</h2><h5 id="我们把在函数体内声明的变量称为该函数的局部变量。"><a href="#我们把在函数体内声明的变量称为该函数的局部变量。" class="headerlink" title="我们把在函数体内声明的变量称为该函数的局部变量。"></a>我们把在函数体内声明的变量称为该函数的<strong>局部变量</strong>。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum_digits(int n) &#123;</span><br><span class="line">int sum = 0; /*local variable*/</span><br><span class="line">while (n &gt; 0) &#123;</span><br><span class="line">sum += n % 10;</span><br><span class="line">n /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，局部变量具有下列性质：</p><ul><li><strong>自动存储期限</strong>。简单来讲，存储期限就是变量在程序运行过程中存在的时间长度。局部变量的存储单元在函数调用时”自动”分配，在函数返回时自动回收，所以称这种变量具有自动存储期限。</li><li><strong>块作用域</strong>。变量的作用域就是：在程序文本中可以引用该变量的部分。局部变量拥有块作用域 ：从变量声明的点开始一直到所在块的末尾。块：简单来说，就是用 {} 括起来的文本区域。</li></ul><h3 id="5-1静态局部变量"><a href="#5-1静态局部变量" class="headerlink" title="5.1静态局部变量"></a>5.1静态局部变量</h3><h5 id="在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："><a href="#在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：" class="headerlink" title="在局部变量声明中使用 static 关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："></a>在局部变量声明中使用 static 关键字，可以使局部变量具有<strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">static int i = 0;</span><br><span class="line">printf(&quot;%p: %d\n&quot;, &amp;i, i++);</span><br><span class="line">&#125;</span><br><span class="line">//静态局部变量始终具有块作用域，所以它对其他函数是不可见的。</span><br></pre></td></tr></table></figure><h5 id="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："><a href="#静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：" class="headerlink" title="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："></a>静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line">long long next_fib(void) &#123;</span><br><span class="line">static long long a = 0;</span><br><span class="line">static long long b = 1;</span><br><span class="line">long long tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = a + tmp;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 2</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 3</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2外部变量"><a href="#5-2外部变量" class="headerlink" title="5.2外部变量"></a>5.2外部变量</h3><p>外部变量(全局变量)就是声明在任何函数体外的变量，外部变量的性质不同于局部变量：</p><ul><li><strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li><li><strong>文件作用域</strong>。从变量声明开始，一直到文件的末尾。因此，在外部变量声明之后的函数都可以访问(并修改)它。</li></ul><p>在多个函数必须共享一个变量时，外部变量是很有用的。然而，在大多数情况下，函数之间通过形式参</p><p>数进行通信会比共享外部变量更好。<strong>使用外部变量不利于程序的排错和维护。</strong></p><h2 id="6-return语句"><a href="#6-return语句" class="headerlink" title="6.return语句"></a>6.return语句</h2><p>void 函数也可以使用 return 语句，使函数立刻返回，只是 return 后面不能接表达式。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print_positive(int n) &#123;</span><br><span class="line">if (n &lt;= 0)</span><br><span class="line">return ;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h2><p>从递归的定义去理解递归不是很好，我们可以从名字入手去理解。</p><ol><li><p>递：把大问题分解成若干个子问题，子问题的求解方式和大问题一致，只是问题规模不一致。</p></li><li><p>归：把子问题的解合并成大问题的解。</p></li></ol><ul><li><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2</span><br><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">return fib(n-2) + fib(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种求解方式的效率很低，会存在大量重复的计算。如下图所示：</p><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230716212709055.png" alt="image-20230716212709055"></p></li></ul><p>so，如何避免重复计算问题呢？</p><p>答案是动态规划。顺序求解子问题，并将子问题的解保存起来，从而避免重复计算，最终求解到大问</p><p>题。</p><p>但是对于求解 Fibnacci 数列来说，我们并不需要保存前面所有项的值，我们只需要保存最近两项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">long long a = 0, b = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">// 计算fib(i)的值</span><br><span class="line">long long tmp = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p><strong>代码实现的思路主要分为三步：</strong><br>假设总共需要移动n个盘子<br>1.将A柱上的n-1个盘子借助C柱移向B柱<br>2.将A柱上仅剩的最后一个盘子移向C柱<br>3.将B柱上的n-1个盘子借助A柱移向C柱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void move(int n, char a, char b, char c) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;, a,c);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">move(n - 1, a, c,b);</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;,a,c );</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">move(n - 1, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;n:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h4><p>哪个人先出列一个人，在重新编号。变成n-1个人，直到只剩下一个人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define  _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">     //             f(N,M)=(f(N−1,M)+M)%N</span><br><span class="line"></span><br><span class="line">int joseph(int n, int m) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123; </span><br><span class="line">return (joseph(n - 1, m) + m) % n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n, m,k;</span><br><span class="line">printf(&quot;输入n：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;\n输入m：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">k=joseph(n, m);</span><br><span class="line">printf(&quot;\n活下来人的编号为：%d&quot;, k+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
