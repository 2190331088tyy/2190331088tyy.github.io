<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2023/07/28/vim/"/>
      <url>/2023/07/28/vim/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h1><p>Vim(Vi improved) 是从 Vi 发展出来的一个文本编辑器。Vim 在程序员中使用地非常广泛，和 Emacs 并称为类 Unix 系统用户最喜欢的文本编辑器。事实上，这两大编辑神器之间的圣战一直没停歇过。</p><span id="more"></span><p><strong>Vim</strong> <strong>的设计理念是</strong> <strong>Composability</strong> (<strong>组合</strong>):</p><p>例如在 Vim 中，”d” 表示删除，”j” 移动到下一行，组合 “dj” 表示删除当前行和下一行；”^” 代表行首，故组合 “d^” 表示删除到行首；”$” 代表行尾，”d$” 表示删除到行尾。而且我们还可以指定命令重复的次数：”dd” 表示删除光标所在行，”2dd” 或”d2d” 表示连续删除两行，效果和 “dj” 一致。</p><p>Vim 是一种模式编辑器，它与我们熟悉的”所见即所得”的编辑器不太一样。Vim 在不同模式下有不同的功能，这也是 Vim 之所有这么 NB 的原因之一。Vim 有多种模式，最常用的是：普通(命令)模式、插入(编辑)模式和视图模式。这些模式之间可以相互转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 在光标前面插入</span><br><span class="line">I: 在行首插入</span><br><span class="line">a: 在光标后面插入</span><br><span class="line">A: 在行尾插入</span><br><span class="line">o: 在下面另起一行，并在行首插入</span><br><span class="line">O: 在上面另起一行，并在行首插入</span><br><span class="line">v: 进入行选模式</span><br><span class="line">[ctrl]+v: 进入竖选模式</span><br></pre></td></tr></table></figure><h2 id="1-1普通模式"><a href="#1-1普通模式" class="headerlink" title="1.1普通模式"></a>1.1普通模式</h2><p>普通模式又叫命令模式，顾名思义，这种模式就是用来执行各种命令的。命令可以分为长命令和短命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">长命令：以:开头，以[Enter]结尾的命令。比如，:wq[Enter]</span><br><span class="line">短命令：如a,o,i...</span><br></pre></td></tr></table></figure><p><strong>移动光标</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">往左移动一个字符</td></tr><tr><td align="center">j</td><td align="center">往下移动一个字符</td></tr><tr><td align="center">k</td><td align="center">往上移动一个字符</td></tr><tr><td align="center">l</td><td align="center">往右移动一个字符</td></tr><tr><td align="center">[n]-</td><td align="center">往上移动n行</td></tr><tr><td align="center">[n]+</td><td align="center">往下移动n行</td></tr><tr><td align="center">:[n] 或 [n]G</td><td align="center">移动到第n行</td></tr><tr><td align="center">gg</td><td align="center">移动到文件的第一行</td></tr><tr><td align="center">G</td><td align="center">移动到文件的最后一行</td></tr><tr><td align="center">^</td><td align="center">移动到这一行的第一个非空白字符处</td></tr><tr><td align="center">$</td><td align="center">移动到行尾</td></tr><tr><td align="center">w</td><td align="center">下一个单词的词首</td></tr><tr><td align="center">b</td><td align="center">上一个单词的词首</td></tr><tr><td align="center">t)</td><td align="center">向后查找，将光标移动到)的前一个字符</td></tr><tr><td align="center">T”</td><td align="center">向前查找，将光标移动到”的后一个字符</td></tr><tr><td align="center">f)</td><td align="center">向后查找，将光标移动到)</td></tr><tr><td align="center">F”</td><td align="center">向前查找，将光标移动到”</td></tr></tbody></table><p><strong>删除文本</strong></p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除一个字符</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词</td></tr><tr><td align="center">[n]dw 或 d[n]w</td><td align="center">删除n个单词</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">[n]dd 或 d[n]d</td><td align="center">删除n行</td></tr><tr><td align="center">:[m],[n]d</td><td align="center">删除[m,n]行</td></tr><tr><td align="center">d^</td><td align="center">删除到行首</td></tr><tr><td align="center">d$</td><td align="center">删除到行尾</td></tr><tr><td align="center">dt)</td><td align="center">删除到)</td></tr><tr><td align="center">dt”</td><td align="center">删除到”</td></tr></tbody></table><p><strong>粘贴，撤销和恢复</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">p 或 P(paste)</td><td align="center">粘贴</td></tr><tr><td align="center">u(undo)</td><td align="center">撤销</td></tr><tr><td align="center">[ctrl] + r(recovery)</td><td align="center">恢复</td></tr></tbody></table><p><strong>复制文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">[n]yy 或 y[n]y</td><td align="center">复制n行</td></tr><tr><td align="center">:[m],[n]y</td><td align="center">复制[m,n]行</td></tr><tr><td align="center">yw</td><td align="center">复制一个单词</td></tr><tr><td align="center">[n]yw 或 y[n]w</td><td align="center">复制n个单词</td></tr><tr><td align="center">yt)</td><td align="center">复制到)</td></tr><tr><td align="center">yt”</td><td align="center">复制到”</td></tr></tbody></table><p><strong>修改文本</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">cc 或 S</td><td align="center">删除当前行，并进入编辑模式</td></tr><tr><td align="center">[n]cc 或 [n]S</td><td align="center">删除n行，并进入编辑模式</td></tr><tr><td align="center">cw</td><td align="center">删除一个单词，并进入编辑模式</td></tr><tr><td align="center">[n]cw 或 c[n]w</td><td align="center">删除n个单词，并进入编辑模式</td></tr><tr><td align="center">c^</td><td align="center">删除到行首，并进入编辑模式</td></tr><tr><td align="center">c$</td><td align="center">删除到行尾，并进入编辑模式</td></tr><tr><td align="center">ct)</td><td align="center">删除到)，并进入编辑模式</td></tr><tr><td align="center">ct”</td><td align="center">删除到”，并进入编辑模式</td></tr><tr><td align="center">c[n]G</td><td align="center">删除到第n行，并进入编辑模式</td></tr><tr><td align="center">cG</td><td align="center">删除到文件末尾，并进入编辑模式</td></tr></tbody></table><p><strong>查找：</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">&#x2F;pattern</td><td align="center">从光标所在位置向后查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">?pattern</td><td align="center">从光标所在位置向前查找匹配pattern的内容，pattern为正则表达式</td></tr><tr><td align="center">n</td><td align="center">移动到下一个匹配项</td></tr><tr><td align="center">N</td><td align="center">移动到上一个匹配项</td></tr></tbody></table><p><strong>替换文本：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> :s/pattern/substitute/选项</span><br><span class="line"> 将匹配pattern的内容替换为substitute</span><br><span class="line">1) :s/pattern/substitute</span><br><span class="line">   只会替换光标所在行的第一个匹配项</span><br><span class="line">2) :s/pattern/substitute/g</span><br><span class="line"> 替换光标所在行的所有匹配项 (g for globally)</span><br><span class="line">3) :[m],[n]s/pattern/substitute/g</span><br><span class="line"> 替换[m,n]行的所有匹配项</span><br><span class="line">4) :%s/pattern/substitute/g</span><br><span class="line"> 替换全文的所有匹配项</span><br></pre></td></tr></table></figure><h2 id="1-2视图模式"><a href="#1-2视图模式" class="headerlink" title="1.2视图模式"></a>1.2视图模式</h2><p>视图模式是用来选择内容的。选择内容之后，我们就可以对其进行复制或删除了。进入视图模式有两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v: 行选模式</span><br><span class="line">[ctrl]+v: 竖选模式</span><br></pre></td></tr></table></figure><p>常见用法: 批量注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) [ctrl]+v 进入竖选模式</span><br><span class="line">2) 选择范围</span><br><span class="line">3) 输入I</span><br><span class="line">4) 输入//</span><br><span class="line">5) 输入[ESC]</span><br></pre></td></tr></table></figure><h1 id="2-对文件的操作"><a href="#2-对文件的操作" class="headerlink" title="2.对文件的操作"></a>2.对文件的操作</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">将buffer里面的内容写入文件，即保存</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存退出</td></tr><tr><td align="center">:wq</td><td align="center">保存退出</td></tr></tbody></table><p>注意：[ctrl] + s 不表示保存，而是进入僵死状态；[ctrl] + q 可以退出僵死状态。</p><h1 id="3-多窗口"><a href="#3-多窗口" class="headerlink" title="3.多窗口"></a>3.多窗口</h1><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">:split (:sp)</td><td align="center">水平分割</td></tr><tr><td align="center">:new</td><td align="center">水平分割</td></tr><tr><td align="center">:vsplit (:vsp)</td><td align="center">垂直分割</td></tr><tr><td align="center">:vnew</td><td align="center">垂直分割</td></tr><tr><td align="center">[ctrl]+ww</td><td align="center">切换窗口</td></tr><tr><td align="center">:wall</td><td align="center">保存所有修改过的窗口</td></tr><tr><td align="center">:qall</td><td align="center">退出所有窗口</td></tr><tr><td align="center">:only</td><td align="center">保留当前窗口，关闭所有其它窗口</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/07/28/linux-ming-ling/"/>
      <url>/2023/07/28/linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p><strong>查看帮助手册</strong></p><p>使用 man(manual) 命令可以查看 Linux 内置的帮助手册。该手册分为多卷：第一卷是用来查看 shell 命令的；第二卷是用来查看系统调用相关信息的；第三卷是用来查看库函数信息的…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1   可执行程序或 shell 命令</span><br><span class="line">2   系统调用(内核提供的函数)</span><br><span class="line">3   库调用(程序库中的函数)</span><br><span class="line">4   特殊文件(通常位于 /dev)</span><br><span class="line">5   文件格式和规范，如 /etc/passwd</span><br><span class="line">6   游戏</span><br><span class="line">7   杂项(包括宏包和规范，如 man(7)，groff(7))</span><br><span class="line">8   系统管理命令(通常只针对 root 用户)</span><br><span class="line">9   内核例程 [非标准</span><br></pre></td></tr></table></figure><p>man命令的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ man [手册编号] cmd</span><br><span class="line">$ man man</span><br><span class="line">$ man 3 mkdir</span><br></pre></td></tr></table></figure><p>进入帮助界面后，我们可以按下面按键浏览帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d(down): 往下翻半页</span><br><span class="line">u(up): 往上翻半页</span><br><span class="line">f(forward): 往下翻一整页</span><br><span class="line">b(backward):往上翻一整页</span><br><span class="line">q(quit): 退出</span><br></pre></td></tr></table></figure><p><strong>关机命令</strong></p><p>关闭主机之前，请务必先关闭虚拟机！否则，可能会损坏虚拟机文件，导致不能启动虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ man shutdown</span><br><span class="line"> shutdown - 挂起，关机或重启计算机</span><br><span class="line">常用选项：</span><br><span class="line"> -H, --halt: 挂起</span><br><span class="line"> -P, --poweroff: 关机(默认)</span><br><span class="line"> -r, --reboot: 重启</span><br><span class="line"> -c(cancel): 取消</span><br><span class="line"> </span><br><span class="line"> $ sudo shutdown</span><br><span class="line"> 广播关机消息给所有用户，并于一分钟后关机。</span><br><span class="line">$ sudo shutdown now</span><br><span class="line"> 立刻关机</span><br></pre></td></tr></table></figure><h2 id="用户子系统"><a href="#用户子系统" class="headerlink" title="用户子系统"></a>用户子系统</h2><p>Linux 用户可以分为：超级用户(root)和普通用户。超级用户又被称为：根用户和特权用户，它拥有至高无上的权利。普通用户又被划分为管理用户和其它用户。管理用户即我们俗称的 sudoers，他们可以临时提升权限(使用sudo命令)，安装Ubuntu过程中创建的用户默认就是 sudoers。</p><p><strong>查看所有用户</strong></p><p>Linux系统下的所有用户，在 passwd 配置文件中都有一条相关记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">he:x:1000:1000:he,,,:/home/he:/bin/bash</span><br><span class="line"></span><br><span class="line">//每一行对应一条记录，每条记录有多个字段，字段之间以 : 分割。我们可以在5号手</span><br><span class="line">册中查看 passwd 文件的格式和规范：</span><br><span class="line">$ man 5 passwd</span><br><span class="line">/etc/passwd 为每个用户账户包含一行，包含使用冒号 (“:”) 分隔的七个字段，分别是：</span><br><span class="line"> ·   登录名</span><br><span class="line"> ·   可选的加密后的密码</span><br><span class="line"> ·   数字用户 ID</span><br><span class="line"> ·   数字组 ID</span><br><span class="line"> ·   用户名和注释字段</span><br><span class="line"> ·   用户主目录</span><br><span class="line"> ·   可选的用户命令解释器</span><br></pre></td></tr></table></figure><p><strong>添加用户</strong></p><p>使用useradd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    useradd [选项] username</span><br><span class="line">    常用的选项：</span><br><span class="line">    -m, --create-home   如果不存在则创建用户的主目录</span><br><span class="line">    -s, --shell         用户的登录shell名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd test1 </span><br><span class="line"> 这样的创建该用户不会创建主目录，默认的shell为sh</span><br><span class="line">sudo useradd -m -s /bin/bash test2</span><br><span class="line"> 这样的创建该用户会创建主目录，并且指定了使用/bin/bash shell</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><p>使用userdel命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">userdel [选项] username</span><br><span class="line">常用选项：</span><br><span class="line">    -r.--remove      用户主目录中的文件将随主目录和用户邮箱一起删除</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel test1</span><br><span class="line">不会删除用户的家目录和用户的邮箱</span><br><span class="line">sudo userdel -r </span><br><span class="line">会把用户的家目录和用户的邮箱一起删除</span><br></pre></td></tr></table></figure><p><strong>设置密码</strong></p><p>使用passwd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">passwd [选项] [username]  </span><br><span class="line">可以更改用户密码，普通用户只能修改自己的密码，超级用户则可以修改任意用户的密码</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd test1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>切换用户</strong></p><p>使用su(switch user)命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sude su  切换到su用户</span><br></pre></td></tr></table></figure><p><strong>退出切换</strong></p><p>使用exit命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit    退出用户切换</span><br></pre></td></tr></table></figure><p>ps: </p><p>使用su命令依次切换到多个用户的时候，这些用户时使用栈结构来管理的。执行su命令相当于将用户压入栈顶，执行exit命令相当于将用户弹出栈顶。</p><p>当用户在上述的栈结构中存在的时候，该用户是不能被删除的。</p><h2 id="文件子系统"><a href="#文件子系统" class="headerlink" title="文件子系统"></a>文件子系统</h2><h3 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h3><p>和 Windows 不一样，Linux是以树的结构来管理文件系统的。我们将树的根结点称为根目录，用 &#x2F; 表示。</p><p><strong>常见目录</strong></p><p>在Linux中，我们是以分门别类的方式来管理文件的，也就是说，我们会将功能相似的文件放到同一个目录下进行管理。这和Windows按工程组织文件的方式不太一样。</p><p>常见目录的功能如下表所示：</p><table><thead><tr><th align="center"><strong>目录名</strong></th><th align="center"><strong>功能</strong></th></tr></thead><tbody><tr><td align="center">&#x2F;bin(binary)</td><td align="center">存放可执行程序或脚本文件</td></tr><tr><td align="center">&#x2F;sys(system)</td><td align="center">存放和系统相关的文件</td></tr><tr><td align="center">&#x2F;dev(device)</td><td align="center">存放设备文件</td></tr><tr><td align="center">&#x2F;etc</td><td align="center">一般用来存放配置文件和启动脚本</td></tr><tr><td align="center">&#x2F;lib(library)</td><td align="center">存放系统库文件</td></tr><tr><td align="center">&#x2F;var(variable)</td><td align="center">存放变化很快的文件，比如日志文件</td></tr><tr><td align="center">&#x2F;proc(process)</td><td align="center">存放进程相关的数据</td></tr><tr><td align="center">&#x2F;root</td><td align="center">root用户的家目录</td></tr><tr><td align="center">&#x2F;home&#x2F;{username}</td><td align="center">普通用户的家目录</td></tr></tbody></table><p><strong>查看当前工作目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><strong>改变当前目录</strong></p><p>使用cd(change directory)命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cd [选项] [directory]</span><br></pre></td></tr></table></figure><p>常用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd # 切换到用户家目录</span><br><span class="line">$ cd /usr/lib # 切换到/usr/lib目录</span><br><span class="line">$ cd / # 切换到 / 目录</span><br><span class="line">$ cd ~ # 切换到用户家目录</span><br><span class="line">$ cd . # 切换到当前工作目录(不切换)</span><br><span class="line">$ cd .. # 切换到父目录</span><br><span class="line">$ cd - # 切换到上一次目录</span><br></pre></td></tr></table></figure><p>注意：上一次目录保存在环境变量OLDPWD中(可以通过env命令查看)，它不是用栈结构管理的。</p><p><strong>创建目录</strong></p><p>使用mkdir命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">mkdir [选项] directory...</span><br><span class="line">常用选项：</span><br><span class="line"> -p, --parents         如果父目录不存在，则创建父目录</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir dir</span><br><span class="line">$ mkdir dir1 dir2 dir3</span><br><span class="line">$ mkdir -p a/b/c</span><br></pre></td></tr></table></figure><p>删除空目录：</p><p>使用rmdir(只能删除空目录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> rmdir [选项] dirctory...</span><br><span class="line">常用选项：</span><br><span class="line"> -p, --parents</span><br><span class="line">   递归删除空目录</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir dir</span><br><span class="line">$ rmdir dir1 dir2 dir3</span><br><span class="line">$ rmdir -p a/b/c</span><br></pre></td></tr></table></figure><p><strong>通配符</strong></p><p>可以匹配单个或多个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*: 匹配任意多个字符(包括0个)</span><br><span class="line">?: 匹配任意一个字符</span><br><span class="line">集合(类): [characters]匹配集合内任意一个字符。</span><br><span class="line">  [!characters]匹配集合外任意一个字符。</span><br><span class="line">比如：[abc], [!abc], [0-9], [a-z], [0-9A-Za-z_]等</span><br></pre></td></tr></table></figure><p>rmdir命令可以和通配符一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir dir?</span><br><span class="line">$ rmdir dir*</span><br><span class="line">$ rmdir [!abc]</span><br></pre></td></tr></table></figure><p><strong>查看目录内容</strong></p><p>ls命令可以查看目录内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">ls[选项] [FILE]...</span><br><span class="line">常用选项：</span><br><span class="line">-a,--all  显示所有的内容，包括以.开头的文件和目录</span><br><span class="line">-i，--inode  显示文件的inode编号(inode是物理文件的标识)。</span><br><span class="line">-l      以长格式的形式显示目录中的内容</span><br><span class="line">-h,  --human-readable   和-l一起使用，以人类可读的方式显示文件的大小。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls # 查看当前工作目录</span><br><span class="line">$ ls dir # 查看dir</span><br><span class="line">$ ls dir1 dir2 dir3 # 查看dir1,dir2,dir3</span><br><span class="line">$ ls -a dir # 查看dir中的所有内容，包括以.开头的文件和目录</span><br><span class="line">$ ls -ilh dir # 显示inode编号，显示详细信息，并以人类可读的方式显示文</span><br><span class="line">件的大小</span><br></pre></td></tr></table></figure><p>目录的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 8560</span><br><span class="line">-rw-rw-r--  1 he he 4349666 3月   7 11:12 a.txt</span><br><span class="line">drwxrwxr-x  2 he he    4096 3月   2 21:18 c</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>第一列的第一个字母表示文件的类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-: 普通文件</span><br><span class="line">d(directory): 目录</span><br><span class="line">c(character): 字符设备文件(鼠标，键盘，显示器...)</span><br><span class="line">b(block): 块设备文件(磁盘)</span><br><span class="line">l(symbolic link): 符号链接</span><br><span class="line">s(socket): 本地套接字</span><br><span class="line">p(named pipe): 有名管道</span><br></pre></td></tr></table></figure><ul><li><p>第1列后面九个字符(分为3组)表示权限。依次代表拥有者、拥有组和其他用户的读、写、执行权限。可读则显示r，可写则显示w，可执行则显示x， 没有相关权限则显示-。</p></li><li><p>第2列表示硬链接数。</p></li><li><p>第3列表示拥有者。</p></li><li><p>第4列表示拥有组。</p></li><li><p>第5列表示文件所占空间的大小。</p></li><li><p>第6列表示最近修改时间。</p></li><li><p>第7列为文件名。</p></li></ul><p><strong>复制文件和目录</strong></p><p>cp命令可以用来复制文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cp [选项] SOURCE DEST</span><br><span class="line">cp [选项] SOURCE ...DEST</span><br><span class="line">常用选项：</span><br><span class="line">-n, --no-clobber   如果文件已存在，则不覆盖（默认会覆盖已有文件）。</span><br><span class="line">-i, --interactive  如果文件存在，则给用户提示信息（由用户决定是否覆盖）。</span><br><span class="line">-R, -r, --recursive  递归复制（用于copy目录）。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cp text1 text2 # 将text1复制到text2中；如果text2存在，</span><br><span class="line">则覆盖。</span><br><span class="line">$ cp text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；</span><br><span class="line">如果文件已存在，则覆盖。</span><br><span class="line">$ cp -n text1 text2 # 将text1复制到text2中；如果text2存在，</span><br><span class="line">不覆盖。</span><br><span class="line">$ cp -i text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；</span><br><span class="line">如果文件已存在，则提示用户是否覆盖。</span><br><span class="line">$ cp -r dir1 dir2 # 递归地将目录dir1复制到目录dir2</span><br></pre></td></tr></table></figure><p><strong>移动文件和目录</strong></p><p>mv命令可以用来移动文件和目录，也可以用mv命令对文件和目录重命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">mv [选项] SOURCE DEST</span><br><span class="line">mv [选项] SOUCE... DEST</span><br><span class="line">常用选项：</span><br><span class="line">  -n, --no-clobber  如果文件已存在，则不覆盖（默认会覆盖已有文件）。</span><br><span class="line">  -i ,--interactive  如果文件已存在，则会给用户提示信息（由用户决定）。</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv text1 text2 # 将text1重命名为text2；如果text2存在，</span><br><span class="line">则覆盖。</span><br><span class="line">$ mv dir1 dir2 # 将dir1重命名为dir2</span><br><span class="line">$ mv -n text1 text2 # 将text1重命名为text2；如果text2存在，</span><br><span class="line">不覆盖。</span><br><span class="line">$ mv text1 text2 text3 dir # 将text1,text2,text3移动到目录dir中；</span><br><span class="line">如果文件已存在，则覆盖。</span><br><span class="line">$ mv -i text1 text2 text3 dir # 将text1,text2,text3移动到目录dir中；</span><br><span class="line">如果文件已存在，则提示用户是否覆盖。</span><br></pre></td></tr></table></figure><p><strong>删除文件和目录</strong></p><p>rm命令可以删除文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">rm [选项] FILE...</span><br><span class="line">常用选项：</span><br><span class="line">-f,--force   忽略不存在的文件，永不提示。</span><br><span class="line">-i  在每次删除前，都提示用户是否删除</span><br><span class="line">-r, -R ,--recursive   递归删除</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm text1 # 删除文件text1</span><br><span class="line">$ rm text1 text2 text3 # 删除文件text1, text2, text3</span><br><span class="line">$ rm -i *.txt # 删除当前目录下所有以.txt结尾的文件，并提示用户是</span><br><span class="line">否删除</span><br><span class="line">$ rm -rf dir # 递归删除目录dir, 不给出任何提示</span><br></pre></td></tr></table></figure><p>注意：使用rm命令删除文件和目录后，就很难恢复了(Linux系统没有所谓的回收**站)。所以除非必要，不要以 root 身份或者使用 sudo 权限来执行 rm 命令!</p><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><p><strong>创建文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Hello Linus Torvalds&quot; &gt; text  # 创建文件text, 并且文件中包含内容&quot;Hello Linus Torvalds&quot;</span><br><span class="line">$ touch text1 text2 text3          # 创建空文件text1, text2, text3(要求text1,text2,text3不存在)</span><br><span class="line">$ vim hello.c         # 编辑hello.c, 按:wq退出。</span><br></pre></td></tr></table></figure><p><strong>查找文件</strong></p><ol><li><p>使用which命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">which [-a] cmd</span><br><span class="line">选项：</span><br><span class="line">-a      显示所有匹配路径</span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ which bash # 查看bash的路径</span><br><span class="line">$ which ls tree # 查看命令ls和tree的路径</span><br><span class="line">$ which -a vim # 查看vim的所有路径 (我们可能装了多个版本的vim)</span><br></pre></td></tr></table></figure><p>which是根据PATH环境变量中的路径依次去查找的，然后显示第一个匹配项，或者显示所有匹配项。</p><p>可以使用env命令查看环境。由：分隔开。</p></li><li><p>find命令可以在一个目录中递归的查找符合条件的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">find [start-point...] 查找条件   # 省略start-point，默认起始点为当前工作目录</span><br></pre></td></tr></table></figure><p>常用选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-name pattern 查找文件名符合pattern的文件</span><br><span class="line">-type c      查找类型为c的文件：</span><br><span class="line">b(block): 块设备文件</span><br><span class="line"> c(character): 字符设备文件</span><br><span class="line"> d(directory): 目录</span><br><span class="line"> p(named pipe): 有名管道</span><br><span class="line"> f(file): 普通文件</span><br><span class="line"> l(symbolic link): 符号链接</span><br><span class="line">s(socket): 套接字</span><br><span class="line">-size n[cwbkMG]</span><br><span class="line">b: for 512-byte blocks (this is the default if no suffix isused)</span><br><span class="line">     c: for bytes</span><br><span class="line">           w: for two-byte words</span><br><span class="line">           k: for Kibibytes (KiB, units of 1024 bytes)</span><br><span class="line"> M: for Mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes)</span><br><span class="line">           G: for Gibibytes (GiB, units of 1024 * 1024 * 1024 =1073741824 bytes)</span><br><span class="line">           可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。</span><br><span class="line">    -empty   查找空的文件或空的文件夹</span><br><span class="line">    -user username ,-uid uid    根据用户名和用户id查找</span><br><span class="line">    -group groupname ,-gid gid  根据组名和组id查找</span><br><span class="line">    -perm mode                  根据权限查找</span><br><span class="line">根据时间查找：</span><br><span class="line">-amin n, -atime n, -cmin n, -mmin n, -mtime n</span><br><span class="line">a(access):文件访问的时间</span><br><span class="line">c(change):文件属性发生改变的时间</span><br><span class="line">m(modify):文件内容发生改变的时间</span><br><span class="line">min:以分钟为单位</span><br><span class="line">time:以天为单位</span><br><span class="line">可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。</span><br><span class="line">组合查找：</span><br><span class="line">-a(and), -o(or), !(not):分别表示与或非</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>常用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ find /usr/include -name &quot;stdio.h&quot; # 在/usr/include目录下查找stdio.h文件</span><br><span class="line">$ find . -name &quot;*.c&quot; # 在当前工作目录下查找所有以.c结尾的文件</span><br><span class="line">$ find /dev -type b # 在/dev目录下查找所有的块设备文件</span><br><span class="line">$ find . -size 5M # 在当前工作目录下查找所有大小为5M的文件</span><br><span class="line">$ find . -size +5M   # 在当前工作目录下查找所有大于5M的文件</span><br><span class="line">$ find dir1 dir2 dir3 -empty # 在dir1,dir2,dir3目录下查找所有空的文件和空的文件夹</span><br><span class="line">$ find . -user he     # 在当前工作目录下查找he用户拥有的文件</span><br><span class="line">$ find . -gid 0 # 在当前工作目录下查找root组(gid=0)拥有的文件</span><br><span class="line">$ find . -perm 664 # 在当前工作目录下查找权限为664(rwrw-r--)的文件</span><br><span class="line">$ find . -mtime 1 # 在当前工作目录下查找在[1, 2)天前内容发生修改的文件 (find会省略小数部分)</span><br><span class="line">$ find . -mtime +2    # 在当前工作目录下查找在[3, )天前内容发生修改的文件</span><br><span class="line">$ find /dev -type c -a -name &quot;tty*&quot;    # 在/dev目录下查找以tty开头的字符设备文件</span><br><span class="line">$ find /dev -type b -o -name &quot;tty*&quot;    # 在/dev目录下查找块设备文件或者是以tty开头的文件</span><br><span class="line">$ find /dev -type c -a ! -name &quot;tty*&quot; # 在/dev目录下查找不以tty开头的字符设备文件</span><br></pre></td></tr></table></figure><p><strong>查看文件内容</strong></p></li><li><p>使用cat命令查看文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">cat [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-n ,--number</span><br><span class="line">  对每一行进行编导</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd</span><br><span class="line">$ cat -n /etc/passwd</span><br><span class="line">$ sudo cat /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure></li><li><p>使用head命令查看文件的前几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">head [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-n, --lines=[-]NUM</span><br><span class="line">显示前NUM行；若在NUM前面添加&#x27;-&#x27;号，则显示除了后NUM行的所有行</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ head text1 # 显示text1的前10行</span><br><span class="line">$ head text1 text2 text3 # 显示text1,text2,text3的前10行</span><br><span class="line">$ head -n 5 text1 # 显示text1的前5行</span><br><span class="line">$ head -n -5 text1 # 显示除了最后5行的所有行</span><br></pre></td></tr></table></figure></li><li><p>使用tail命令查看文件的后几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> tail [选项] [file]...</span><br><span class="line">常见选项：</span><br><span class="line"> -n, --lines=[+]NUM</span><br><span class="line"> 显示后NUM行；若在NUM前面添加&#x27;+&#x27;号，则从第NUM开始显示</span><br><span class="line"> -F</span><br><span class="line"> 显示后面追加的数据。一般用于查看日志文件。</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail text1 # 显示text1的后10行</span><br><span class="line">$ tail text1 text2 text3 # 显示text1,text2,text3的后10行</span><br><span class="line">$ tail -n 5 text1 # 显示text1的后5行</span><br><span class="line">$ tail -n +5 text1 # 从第5行开始显示</span><br><span class="line">$ tail -F server.log # 显示后10行，并且会显示后面追加的数据</span><br></pre></td></tr></table></figure></li><li><p>使用less(more)单页浏览文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> more [选项] file...</span><br></pre></td></tr></table></figure><p>less是more的高级版本，若系统中没有less命令，才考虑使用more。</p><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ less text1     # 浏览text1</span><br><span class="line">$ less text1 text2    # 浏览text1, text2</span><br></pre></td></tr></table></figure><p>进入浏览页面后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(forward) 往后翻一页</span><br><span class="line">b(backward) 往前翻一页</span><br><span class="line">:n(next) 查看下一个文件</span><br><span class="line">:p(previous) 查看上一个文件</span><br><span class="line">q(quit) 退出浏览界面</span><br></pre></td></tr></table></figure></li></ol><p><strong>重定向</strong></p><p>cat,head,tail等命令经常和重定向一起使用，比如：tail -n 20 text1 &gt; a.txt。</p><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ who &gt; users                            #清空再写入</span><br><span class="line">$ echo &quot;liu yi fei&quot; &gt;&gt; users #追加</span><br><span class="line">$ wc -l &lt; users </span><br><span class="line">$ cat users file1 &gt; text # file1不存在</span><br><span class="line">$ cat users file1 2&gt; text # file1不存在</span><br><span class="line">$ cat users file1 &gt;&amp; text # file1不存在#stdin和stdout  （&gt;&amp;）</span><br></pre></td></tr></table></figure><p>输入重定向用得比较少，输出重定向用得比较多</p><p><strong>搜索文件内容</strong></p><p>grep(globally search for a regular expression)命令可以用于搜索文件内容，它的功能非常强大！grep 命令会按正则表达式去搜索文件，如果文件中某一行匹配指定的正则表达式，grep命令则会显示这一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">grep [选项] pattern [file]...</span><br><span class="line">常见选项：</span><br><span class="line">-E, --extended-regexp   使用扩展的正则表达式</span><br><span class="line">-i, --ignore-case       忽略大小写</span><br><span class="line">-v,--invert-match       显示不匹配的正则表达式的行</span><br><span class="line">-n, --line-number       显示行号</span><br><span class="line">-c, --count             不显示匹配的行，显示匹配行的个数</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -nE &quot;firmament&quot; The_Holy_Bible.txt # 显示The_Holy_Bible.txt中包含&quot;firmament&quot;的所有行，并显示行号</span><br><span class="line">$ grep -cvE &quot;firmament&quot; The_Holy_Bible.txt # 统计The_Holy_Bible.txt中不包含&quot;firmament&quot;的行数</span><br></pre></td></tr></table></figure><p><strong>正则表达式</strong></p><p>正则表达式语法有点复杂，而且不同的工具使用的语法还不尽相同。下面我们介绍一些常用的正则表达式语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 基本单位</span><br><span class="line"> 基本单位主要包含：字符、转义字符、.(匹配任意一个字符)、集合(比如，[abc],[^abc])、(expr)</span><br><span class="line">2. 基本操作</span><br><span class="line"> 操作的对象是基本单位，主要包含两个基本操作：连接和重复</span><br><span class="line"> a. 连接：&quot;ab&quot;, &quot;[abc]x&quot;, &quot;.txt&quot;, &quot;\.txt&quot;</span><br><span class="line"> b. 重复</span><br><span class="line"> +: 重复至少一次(&gt;=1), 比如：&quot;abc+&quot;, &quot;[abc]+&quot;</span><br><span class="line"> ?: 重复零次或一次(0|1), 比如：&quot;abc?&quot;, &quot;[abc]?&quot;</span><br><span class="line"> *: 重复任意次数(&gt;=0), 比如：&quot;abc*&quot;, &quot;[abc]*&quot;, &quot;.*&quot;</span><br><span class="line"> &#123;m&#125;: 重复m次</span><br><span class="line"> &#123;m,n&#125;: 重复m到n次([m,n])</span><br><span class="line"> &#123;n, &#125;: 至少重复n次([&gt;=n])</span><br><span class="line">3. 指定基本单位出现的位置</span><br><span class="line"> ^: 行首，比如：&quot;^abc&quot;</span><br><span class="line"> $: 行尾，比如：&quot;xyz$&quot;</span><br><span class="line"> \&lt;: 词首</span><br><span class="line"> \&gt;: 词尾</span><br></pre></td></tr></table></figure><p><strong>命令的组合</strong></p><p>grep 命令之所以强大，主要在于它可以和其它命令组合使用。命令的组合主要有以下三种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.cmd1 ; cmd2</span><br><span class="line">先执行cmd1，再执行cmd2.如：mkdir dir；cd dir</span><br><span class="line">2.cmd1 | cmd2（管道）</span><br><span class="line">将上一个命令的输出作为下一个命令的输入。如：history|tail -n 20</span><br><span class="line">3.cmd1 | xargs cmd2</span><br><span class="line">xargs(extended arguments) 可以将标准输入里面的每一行转换成命令的参数</span><br><span class="line"> xargs往往和管道一起使用，如：cmd1 | xargs cmd2，它把cmd1输出的每一行作为cmd2的参数</span><br><span class="line"> find . -name &quot;*.c&quot; | xargs grep -nE &quot;\&lt;main\(&quot;       #在当前目录下找出所有.c文件的main函数</span><br></pre></td></tr></table></figure><p><strong>改变文件权限</strong></p><p>使用chmod命令可以改变文件和目录的权限。</p><p>目录：本质就是一个文件。 这个文件的内容是一个一个目录项(directory entry)，在逻辑上，目录项之间是用链表的方式链接起来的。</p><p>权限对于目录文件和普通文件的含义是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">普通文件</span><br><span class="line"> r: 可读</span><br><span class="line"> w: 可写</span><br><span class="line"> x: 可执行 (可执行程序和脚本文件需要x权限才能直接运行)</span><br><span class="line">目录</span><br><span class="line"> r: 可读 (ls)</span><br><span class="line"> w：可写 (在目录下添加和删除文件)</span><br><span class="line"> x: 可执行 (cd，读写权限依赖于x权限，所以目录一般都设置了x权限)</span><br></pre></td></tr></table></figure><p>chmod 目录的用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 文字设定法 (较少使用)</span><br><span class="line"> chmod [ugoa][+=-][rwx] file/dir</span><br><span class="line"> u: user</span><br><span class="line"> g: group</span><br><span class="line"> o: other</span><br><span class="line"> a: all</span><br><span class="line"> +: 添加权限</span><br><span class="line"> -: 删除权限</span><br><span class="line"> =: 将权限设置为</span><br><span class="line">2. 数字设定法 (常用)</span><br><span class="line"> chmod mode file/dir</span><br><span class="line"> mode: 三位八进制数字</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod o+w text1                  #other添加可写权限</span><br><span class="line">$ chmod u=rwx,g=rx,o=r text1       #user权限为rwx,group的权限为rx,other权限为r</span><br><span class="line">$ chmod 664 text1   #rw- rw- r--</span><br></pre></td></tr></table></figure><p><strong>文件创建掩码</strong></p><p>文件和目录在创建的时候都有一个默认的权限，该权限是由文件创建掩码 umask 决定的。我们可以用 umask 命令查看当前的文件创建掩码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ umask</span><br><span class="line">  0002 # 当前的文件创建掩码为2  </span><br></pre></td></tr></table></figure><p>接下来，我们创建文件 text 和目录 dir，查看它们的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxrwxr-x  2 he he 4096 3月  12 20:55 dir/</span><br><span class="line">-rw-rw-r--  1 he he    0 3月  13 20:34 text</span><br></pre></td></tr></table></figure><p>可见当 umask &#x3D; 0002 时，目录的默认权限为 775，文件的默认权限为 664</p><p>将文件创建掩码 umask 设置为 0023</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask 0023</span><br></pre></td></tr></table></figure><p>再创建文件 text1 和目录 dir1，查看它们的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr-xr-- 2 he he 4096 3月  13 20:40 dir1</span><br><span class="line">-rw-r--r-- 1 he he    0 3月  13 20:40 text1</span><br></pre></td></tr></table></figure><p>可见当 umask &#x3D; 0023 时，目录的默认权限为 754，文件的默认权限为 644 (643-023)</p><p><strong>目录的权限初始为777，普通文件的权限初始为666，与umask相与后为默认权限。</strong></p><p><strong>链接</strong></p><p>我们可以用 ln 命令创建硬链接和符号连接(软链接)。</p><p>创建硬链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ln text1 h_link</span><br><span class="line">$ ls -li</span><br><span class="line">268648 -rw-r--r-- 2 he he    0 3月  13 20:40 h_link</span><br><span class="line">268648 -rw-r--r-- 2 he he    0 3月  13 20:40 text1</span><br></pre></td></tr></table></figure><p>可见 text1 和 h_link 是指向同一个文件的，并且硬链接数也由原来的 1 变成了 2。删除 text1 或 h_link 只会减少硬链接数，当硬链接数为 0 的时候，才会真正删除磁盘上的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm text1</span><br><span class="line">$ ls -li</span><br><span class="line">268648 -rw-r--r-- 1 he he    0 3月  13 20:40 h_link       # 硬链接数变为了 1</span><br><span class="line">$ rm h_link</span><br></pre></td></tr></table></figure><p>创建符号链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s text s_link</span><br><span class="line">$ ls -li</span><br><span class="line">268648 lrwxrwxrwx 1 he he 4 3月  13 21:24 s_link -&gt; text # s_link文件的内容为text，因此大小为4</span><br><span class="line">264859 -rw-rw-r-- 1 he he 0 3月  13 20:34 text</span><br></pre></td></tr></table></figure><p>可见 text 和 s_link 是指向不同文件的，text 的硬链接数不会发生改变。删除 text 会导致符号链接 s_link 悬空：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm text</span><br><span class="line">$ ls -li</span><br><span class="line">268648 lrwxrwxrwx 1 he he 4 3月  13 21:24 s_link -&gt; text # 颜色会发生</span><br><span class="line">改变</span><br></pre></td></tr></table></figure><p>我们可以将符号链接和 Windows 系统上的快捷方式，或者 C 语言中的指针做类比。对于大多数命令(rm除外)，如果参数是符号链接，其实操作的是符号链接指向的文件(类似指针的解引用操作)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;I love xixi\n&quot; &gt; text</span><br><span class="line">$ cat s_link</span><br><span class="line">I love xixi</span><br><span class="line">$ rm s_link # 删除符号链接</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><strong>远程复制</strong></p><p>scp 命令可以用于上传和下载文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上传：将本地的文件复制到远程</span><br><span class="line">下载：将远程的文件复制到本地</span><br></pre></td></tr></table></figure><p>scp 的用法和 cp 非常类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> scp [选项] SRC... DEST</span><br><span class="line"> 本地路径：可以用绝对路径，也可以用相对路径</span><br><span class="line"> 远程路径：用户名@IP:路径</span><br><span class="line">常用选项：</span><br><span class="line"> -r      </span><br><span class="line"> 递归复制整个目录</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp he@IP:~/text1 . # 将he用户家目录下的text1文件下载到当前工作目录</span><br><span class="line">$ scp ./file he@IP:~ # 将当前工作目录下的file文件上传到he用户的家目录下</span><br></pre></td></tr></table></figure><p><strong>打包压缩</strong></p><p>我们可以用 tar 命令打包和压缩文件。tar 是一个非常有历史的工具，这里我们只介绍它的传统(经典)用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> tar [主选项+辅选项] 包名 [文件或目录]...</span><br><span class="line"> 主选项(有且只能选择其中一个)：</span><br><span class="line"> c: 创建</span><br><span class="line"> r: 追加</span><br><span class="line"> x: 释放</span><br><span class="line"> 辅选项：</span><br><span class="line"> f: 指定包文件的名称</span><br><span class="line"> v: 显示详细信息</span><br><span class="line"> z: 使用gzip算法压缩或解压缩包文件</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf package.tar text*</span><br><span class="line">$ tar rvf package.tar The_Holy_Bible.txt</span><br><span class="line">$ tar xvf package.tar</span><br><span class="line">$ tar czvf package.tar.gz *</span><br><span class="line">$ tar xzvf package.tar.gz</span><br></pre></td></tr></table></figure><p><strong>别名</strong></p><p>有些命令比较长，自然我们就想给这些命令起一个别名，方便以后使用，alias 命令就是用来做这事情的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"> alias [命令=别名]...</span><br></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ alias # 查看别名</span><br><span class="line">alias g++11=&#x27;g++ -std=c++11&#x27;</span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">...</span><br><span class="line">$ alias h=&#x27;history&#x27; # 设置别名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章数组和第七章递归</title>
      <link href="/2023/07/28/di-liu-zhang-shu-zu-di-qi-zhang-di-gui/"/>
      <url>/2023/07/28/di-liu-zhang-shu-zu-di-qi-zhang-di-gui/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们见过的变量都只能存储单个数据项，这样的变量称为标量(scalar)。C 语言也支持聚合变量，这类变量可以存储多个数据项。C 语言提供两种类型的聚合变量：数组和结构体。</p><span id="more"></span><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1.一维数组"></a>1.一维数组</h2><h3 id="内存模型："><a href="#内存模型：" class="headerlink" title="内存模型："></a>内存模型：</h3><h4 id="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"><a href="#一片连续的内存空间，并且这片空间划分成大小相等的小空间。" class="headerlink" title="一片连续的内存空间，并且这片空间划分成大小相等的小空间。"></a>一片连续的内存空间，并且这片空间划分成大小相等的小空间。</h4><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><p>（初始化）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[10]=&#123;1,2&#125;;</span><br><span class="line">int a[]=&#123;1,2,3,4&#125;;</span><br></pre></td></tr></table></figure><p>编译器会利用初始化式的长度来确定数组的长度，数组的长度为初始值。</p><h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2.二维数组"></a>2.二维数组</h2><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><h4 id="元素是一维数组的数组。"><a href="#元素是一维数组的数组。" class="headerlink" title="元素是一维数组的数组。"></a>元素是一维数组的数组。</h4><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;1, 1, 0, 1, 0, 0, 1, 1, 1&#125;&#125;;</span><br><span class="line"> //如果初始化式的长度不够，那么剩余元素被初始化为 0。如，下面的初始化式只填充了数组的前 3 行，后面 2 行将被 //初始化为 0。</span><br><span class="line"> int matrix[5][9] = &#123;&#123;1, 1, 1, 1, 1, 0, 1, 1, 1&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 0, 1, 0, 1, 0&#125;,</span><br><span class="line">                   &#123;0, 1, 0, 1, 1, 0, 0, 1, 0&#125;&#125;;</span><br><span class="line">    //甚至，我们可以省略内存的大括号 (不推荐)。</span><br><span class="line">    int matrix[5][9] = &#123;1, 1, 1, 1, 1, 0, 1, 1, 1,</span><br><span class="line">                    0, 1, 0, 1, 0, 1, 0, 1, 0,</span><br><span class="line">                    0, 1, 0, 1, 1, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 0, 1, 0,</span><br><span class="line">                    1, 1, 0, 1, 0, 0, 1, 1, 1&#125;;</span><br></pre></td></tr></table></figure><p>编译器一旦发现值足以填满一行，它就开始填充下一行。</p><p><strong>ps:在初始化式中省略内层大括号是非常危险的，因为不小心多写或者少写一</strong></p><p><strong>个值都会影响后面元素的初始化。</strong></p><h2 id="3-常量数组"><a href="#3-常量数组" class="headerlink" title="3.常量数组"></a>3.常量数组</h2><h5 id="无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”："><a href="#无论是一维数组还是二维数组，我们都可以在声明时加上-const-修饰符而变成-“常量”：" class="headerlink" title="无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”："></a>无论是一维数组还是二维数组，我们都可以在声明时加上 const 修饰符而变成 “常量”：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char hex_chars[] =</span><br><span class="line"> &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,</span><br><span class="line"> &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;;</span><br></pre></td></tr></table></figure><h5 id="程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"><a href="#程序在运行期间不会对数组进行修改。-const-不仅仅可以修饰数组，它可以修饰任意变量。但是-const-在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。" class="headerlink" title="程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。"></a>程序在运行期间不会对数组进行修改。 const 不仅仅可以修饰数组，它可以修饰任意变量。但是 const 在数组声明中特别有用，因为数组经常包含一些不会发生改变的信息。</h5><h4 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h4><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714230439487.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714230439487.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714230439487"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(0));//初始化种子为随机值</span><br><span class="line">const char hex_chars[][13] = &#123; &#123;&#x27;a&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,&#x27;t&#x27;,&#x27;j&#x27;,&#x27;q&#x27;,&#x27;k&#x27;&#125;,</span><br><span class="line">  &#123;&#x27;d&#x27;, &#x27;h&#x27;, &#x27;c&#x27;, &#x27;s&#x27;&#125; &#125;;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;发几张牌：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">bool arr[4][13] = &#123; false &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; ) &#123;</span><br><span class="line">int num1,num2;</span><br><span class="line">num1 = rand() % 13;</span><br><span class="line">num2 = rand() % 4;</span><br><span class="line">if (arr[num2 ][num1 ]==false ) &#123;</span><br><span class="line">arr[num2][num1] = true;</span><br><span class="line">i++;</span><br><span class="line">printf(&quot;%c%c\n&quot;, hex_chars[0][num1], hex_chars[1][num2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1函数的定义"><a href="#1函数的定义" class="headerlink" title="1函数的定义"></a>1函数的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return-type function-name (parameters) &#123;</span><br><span class="line">declarations</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。"><a href="#返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为-void，则函数没有返回值。如果省略返回值类型，C89-会假定返回值类型为-int；但在-C99-中这是不合法的。" class="headerlink" title="返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。"></a>返回值类型遵循以下规则：函数不能返回数组，除此之外，函数可以返回任意类型的值。如果函数的返回值类型为 void，则函数没有返回值。如果省略返回值类型，C89 会假定返回值类型为 int；但在 C99 中这是不合法的。</h5><h5 id="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。"><a href="#函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为-void。" class="headerlink" title="函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。"></a>函数名的后面是形式参数列表。我们需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，那么应该标明为 void。</h5><h5 id="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"><a href="#函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。" class="headerlink" title="函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。"></a>函数体内包含声明和语句。在函数体内声明的变量只属于此函数，其他函数不能访问和修改这些变量。</h5><h2 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2.函数的调用"></a>2.函数的调用</h2><h5 id="函数调用由函数名和实际参数-argument-列表组成。"><a href="#函数调用由函数名和实际参数-argument-列表组成。" class="headerlink" title="函数调用由函数名和实际参数 (argument) 列表组成。"></a>函数调用由函数名和实际参数 (argument) 列表组成。</h5><h5 id="void-函数调用必须紧跟分号，如："><a href="#void-函数调用必须紧跟分号，如：" class="headerlink" title="void 函数调用必须紧跟分号，如："></a>void 函数调用必须紧跟分号，如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_pun();</span><br></pre></td></tr></table></figure><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714231132461.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230714231132461.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714231132461"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">int k = sqrt(n); int i;</span><br><span class="line">for ( i = 2; i &lt;=k; i++) &#123;</span><br><span class="line">if (n % i == 0) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (i &lt;= k)return false;</span><br><span class="line">else return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int m;</span><br><span class="line">printf(&quot;输入m:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">if (isPrime(m)) &#123;</span><br><span class="line">printf(&quot;\n%d为素数&quot;, m);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;\n%d不为素数&quot;, m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实际参数"><a href="#3-实际参数" class="headerlink" title="3.实际参数"></a>3.实际参数</h2><h5 id="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"><a href="#形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。" class="headerlink" title="形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。"></a>形参和实参的区别：形式参数出现在函数定义中，它们表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。</h5><h5 id="在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"><a href="#在-C-语言中实参是值传递-passed-by-value-的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。" class="headerlink" title="在 C 语言中实参是值传递 (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。"></a>在 C 语言中实参是<strong>值传递</strong> (passed by value) 的。调用函数时，计算每个实参的值并把它赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，这是因为形参中保留的其实是实参的副本。</h5><h5 id="但是值传递也会使得某些函数变得难以编写。如："><a href="#但是值传递也会使得某些函数变得难以编写。如：" class="headerlink" title="但是值传递也会使得某些函数变得难以编写。如："></a>但是值传递也会使得某些函数变得难以编写。如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;//error</span><br></pre></td></tr></table></figure><p>PS<br>局部变量：定义在函数内部的变量只能在函数内部使用。<br>上面代码里在main函数中定义的a，b与Swap函数中a，b只是同名，只在Swap函数中交换a与b的值而不影响main函数中的a与b的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sawp(int *p1,int *p2)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">tmp=*p1;//tmp＝a</span><br><span class="line">*p1=*p2;//a＝b</span><br><span class="line">*p2=tmp;//b＝tmp</span><br><span class="line">&#125;  //true</span><br></pre></td></tr></table></figure><p>一个函数（父函数）调用另一个函数（子函数），想通过子函数修改父函数的数据，必须传指针，子函数内部解引用。也就是子函数的改变要想影响父函数的数据必须传指针和解引用。</p><h2 id="4-数组作为参数"><a href="#4-数组作为参数" class="headerlink" title="4.数组作为参数"></a>4.数组作为参数</h2><h5 id="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："><a href="#我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：" class="headerlink" title="我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度："></a>我们经常把数组当作参数。当形式参数为一维数组时，我们可以不指定它的长度：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f(int a[]) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组作为参数传递时，会退化成指向数组第一个元素的指针"><a href="#数组作为参数传递时，会退化成指向数组第一个元素的指针" class="headerlink" title="数组作为参数传递时，会退化成指向数组第一个元素的指针"></a><strong>数组作为参数传递时，会退化成指向数组第一个元素的指针</strong></h4><h5 id="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"><a href="#实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C-语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。" class="headerlink" title="实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。"></a>实参可以是元素类型匹配的任意一维数组。不过这里有一个问题：函数如何知道数组的长度呢？可惜的是，C 语言没有提供任何简便的方法供函数确定数组的长度。如果需要，我们必须额外提供一个长度参数。</h5><h5 id="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："><a href="#如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度-why-。例如，如果-sum-array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：" class="headerlink" title="如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量："></a>如果形式参数是多维数组，声明参数时我们只能省略第一个维度的长度 (why?)。例如，如果 sum_array函数的第一个参数是二维数组，我们可以不指定行的数量，但是必须指定列的数量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define LEN 10</span><br><span class="line">int sum_array(int a[][LEN], int n) &#123;</span><br><span class="line">int i, j, sum = 0;</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">for (j = 0; j &lt; LEN; j++)</span><br><span class="line">sum += a[i][j];</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-局部变量和外部变量"><a href="#5-局部变量和外部变量" class="headerlink" title="5.局部变量和外部变量"></a>5.局部变量和外部变量</h2><h5 id="我们把在函数体内声明的变量称为该函数的局部变量。"><a href="#我们把在函数体内声明的变量称为该函数的局部变量。" class="headerlink" title="我们把在函数体内声明的变量称为该函数的局部变量。"></a>我们把在函数体内声明的变量称为该函数的<strong>局部变量</strong>。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum_digits(int n) &#123;</span><br><span class="line">int sum = 0; /*local variable*/</span><br><span class="line">while (n &gt; 0) &#123;</span><br><span class="line">sum += n % 10;</span><br><span class="line">n /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，局部变量具有下列性质：</p><ul><li><strong>自动存储期限</strong>。简单来讲，存储期限就是变量在程序运行过程中存在的时间长度。局部变量的存储单元在函数调用时”自动”分配，在函数返回时自动回收，所以称这种变量具有自动存储期限。</li><li><strong>块作用域</strong>。变量的作用域就是：在程序文本中可以引用该变量的部分。局部变量拥有块作用域 ：从变量声明的点开始一直到所在块的末尾。块：简单来说，就是用 {} 括起来的文本区域。</li></ul><h3 id="5-1静态局部变量"><a href="#5-1静态局部变量" class="headerlink" title="5.1静态局部变量"></a>5.1静态局部变量</h3><h5 id="在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："><a href="#在局部变量声明中使用-static-关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：" class="headerlink" title="在局部变量声明中使用 static 关键字，可以使局部变量具有静态存储期限。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如："></a>在局部变量声明中使用 static 关键字，可以使局部变量具有<strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">static int i = 0;</span><br><span class="line">printf(&quot;%p: %d\n&quot;, &amp;i, i++);</span><br><span class="line">&#125;</span><br><span class="line">//静态局部变量始终具有块作用域，所以它对其他函数是不可见的。</span><br></pre></td></tr></table></figure><h5 id="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："><a href="#静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：" class="headerlink" title="静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如："></a>静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line">long long next_fib(void) &#123;</span><br><span class="line">static long long a = 0;</span><br><span class="line">static long long b = 1;</span><br><span class="line">long long tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = a + tmp;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 1</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 2</span><br><span class="line">printf(&quot;%lld\n&quot;, next_fib()); // 3</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2外部变量"><a href="#5-2外部变量" class="headerlink" title="5.2外部变量"></a>5.2外部变量</h3><p>外部变量(全局变量)就是声明在任何函数体外的变量，外部变量的性质不同于局部变量：</p><ul><li><strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li><li><strong>文件作用域</strong>。从变量声明开始，一直到文件的末尾。因此，在外部变量声明之后的函数都可以访问(并修改)它。</li></ul><p>在多个函数必须共享一个变量时，外部变量是很有用的。然而，在大多数情况下，函数之间通过形式参</p><p>数进行通信会比共享外部变量更好。<strong>使用外部变量不利于程序的排错和维护。</strong></p><h2 id="6-return语句"><a href="#6-return语句" class="headerlink" title="6.return语句"></a>6.return语句</h2><p>void 函数也可以使用 return 语句，使函数立刻返回，只是 return 后面不能接表达式。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print_positive(int n) &#123;</span><br><span class="line">if (n &lt;= 0)</span><br><span class="line">return ;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h2><p>从递归的定义去理解递归不是很好，我们可以从名字入手去理解。</p><ol><li><p>递：把大问题分解成若干个子问题，子问题的求解方式和大问题一致，只是问题规模不一致。</p></li><li><p>归：把子问题的解合并成大问题的解。</p></li></ol><ul><li><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 0, 1, 1, 2</span><br><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">return fib(n-2) + fib(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种求解方式的效率很低，会存在大量重复的计算。如下图所示：</p><p><img src="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230716212709055.png" class="lazyload placeholder" data-srcset="C:\Users\21903\AppData\Roaming\Typora\typora-user-images\image-20230716212709055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230716212709055"></p></li></ul><p>so，如何避免重复计算问题呢？</p><p>答案是动态规划。顺序求解子问题，并将子问题的解保存起来，从而避免重复计算，最终求解到大问</p><p>题。</p><p>但是对于求解 Fibnacci 数列来说，我们并不需要保存前面所有项的值，我们只需要保存最近两项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long long fib(int n) &#123;</span><br><span class="line">if (n == 0 || n == 1) return n;</span><br><span class="line">long long a = 0, b = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">// 计算fib(i)的值</span><br><span class="line">long long tmp = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p><strong>代码实现的思路主要分为三步：</strong><br>假设总共需要移动n个盘子<br>1.将A柱上的n-1个盘子借助C柱移向B柱<br>2.将A柱上仅剩的最后一个盘子移向C柱<br>3.将B柱上的n-1个盘子借助A柱移向C柱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void move(int n, char a, char b, char c) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;, a,c);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">move(n - 1, a, c,b);</span><br><span class="line">printf(&quot;%c--&gt;%c&quot;,a,c );</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">move(n - 1, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;n:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h4><p>哪个人先出列一个人，在重新编号。变成n-1个人，直到只剩下一个人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define  _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">     //             f(N,M)=(f(N−1,M)+M)%N</span><br><span class="line"></span><br><span class="line">int joseph(int n, int m) &#123;</span><br><span class="line">if (n == 1) &#123;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123; </span><br><span class="line">return (joseph(n - 1, m) + m) % n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">int n, m,k;</span><br><span class="line">printf(&quot;输入n：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;\n输入m：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">k=joseph(n, m);</span><br><span class="line">printf(&quot;\n活下来人的编号为：%d&quot;, k+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
